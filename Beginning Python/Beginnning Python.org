#+TITLE:Beginning Python: From Novice to Prefessional
* The Basics

** Numbers and Expressions

   #+BEGIN_SRC python
   >>> 1.0 / 2.0
   0.5

   >>> 1 / 2.0
   0.5

   >>> 1.0 / 2
   0.5

   >>> 1 / 2.
   0.5
   #+END_SRC

   Real numbers are called /floats/ (or /floating-point numbers) in Python. If
   either one of the numbers in a division is a float, the result will be, too:
   If you would rather have Python do proper division, you could add the follwing
   statement to the beginning of your program:
   Another alternative, if you're running Python from the command line, is to supply
   the command-line switch -Qnew. In either case, division will suddenly make a bit
   more sense:
   Of course, the single slash can no longer be used for the kind of integer division
   shown earlier. A separate operator will do this - double slash:

   #+BEGIN_SRC python
   >>> from __future__ import division
   #+END_SRC

   #+BEGIN_SRC python
   >>> 1 / 2
   0.5
   #+END_SRC

   #+BEGIN_SRC python
   >>> 1 // 2
   0
   #+END_SRC

   The double slash conistently perofrms integer division, even with floats:

   #+BEGIN_SRC python
   >>> 1.0 // 2.0
   0.0
   #+END_SRC

   The remainder(modulus) operator x % y gives the remainder of x divided by y,
   and it works just fine with floats as well

   #+BEGIN_SRC python
   >>> 2.75 % 0.5
   0.25
   #+END_SRC

   The exponentiation(or power)operator:

   #+BEGIN_SRC python
   >>> 2 ** 3
   8
   >>> -3 ** 2
   -9
   >>> (-3) ** 2
   9
   #+END_SRC

** Statements

   *Note:* In Python 3.0, *print* is a function, which means you need to
   write print(...) instead of print ...

*** The IF statement

    #+BEGIN_SRC python
    >>> if 1 == 2: print 'One equals two'
    ...
    >>> if 1 == 1: pirnt 'One equals one'
    #+END_SRC

** Modules

   Modules is extensions that can be imported into Python to extend its
   capabilities. You import modules with a special command called(naturally
   enough) *import*.

   If you are sure that you won't import more than one function with a given name,
   you might not want to write the module name each time you call the function.
   Then you can use a variant of the *import* command:

   #+BEGIN_SRC python
   >>> from math import sqrt
   >>> sqrt(9)
   3.0
   #+END_SRC

** cmath and Complex Numbers

   Complex number is covered by a different module, *cmath* (for complex math):

   #+BEGIN_SRC python
   >>> import cmath
   >>> cmath.sqrt(-1)
   1j
   #+END_SRC

** Back to the __future__

   From it, we can import features that will be standard in Python in the future
   but that aren’t part of the language yet.

** Making scripts behave like normal programs

   In UNIX, there is a standard way of doing this: have the first line of your
   script begin with the character sequence #! (called pound bang or shebang)
   followed by the absolute path to the program that interprets the script (in
   our case Python). Even if you didn’t quite understand that, just put the
   following in the first line of your script if you want it to run easily on UNIX:

   #!/usr/bin/env python

   This should run the script, regardless of where the Python binary is located.

   *Note:* In some operating systems if you install a recent version of Python (e.g., 3.0)
   you will still have an old one lying around (e.g.,2.7), which is needed by some
   system programs (so you can’t uninstall it). In such cases, the /usr/bin/env
   trick is not a good idea, as you will probably end up with your programs being
   executed by the old Python. Instead, you should find the exact location of your
   new Python executable (probably called python or python2.7 ) and use the full
   path in the pound bang line, like this:

   #!/usr/bin/python2

   The exact path may vary from system to system.

   Before you can actually run your script, you must make it executable:

   $ chmod a+x hello.py

   Now it can be run like this (assuming that you have the current directory in your path):

   $ hello.py

   If this doesn’t work, try using ./hello.py instead, which will work even if the current
   directory (.) is not part of your execution path.
   If you like, you can rename your file and remove the py suffix to make it look more like a
   normal program.

** Comments

   The hash sign (#) is a bit special in Python. When you put it in your code,
   everything to the right of it is ignored (which is why the Python interpreter
   didn’t choke on the /usr/bin/env stuff used earlier). Here is an example:

   #+BEGIN_SRC python
   # Print the circumference of the circle:
   print 2 * pi * radius
   #+END_SRC

** Strings

*** String Representations, repr and str

   *str* and *repr* simply converts a value into a string, for example, repr creates a
   string that is a representation of the value as a legal Python expressoion.

   #+BEGIN_SRC python
   >>> print repr("Hello, world!")
   'Hello, world!'
   >>> print repr(10000L)
   10000L
   >>> print str("Hello, world!")
   Hello, world!
   >>> print str(10000L)
   10000
   #+END_SRC

   A synonym for repr(x) is `x`(here, you use backticks, not single quotes).
   *Note:* Backticks are removed in Python 3.0.

   In short, *str*, *repr* and backticks are three ways of converting a Python value to a
   string. The function *str* makes it look good, while repr(and the backticks) tries to make
   the resulting string a legal Python expression.

*** input vs. raw_input

   *input* assumes that what you enter is a valid Python expression(it's more or less the inverse
   of *repr*). For example, if you write your name as a string, that's no problem.
   However, it's just a bit too much to as that users write their name in quotes like that. Therefore
   we use *raw_input*,whick treats all input as raw data and puts it into a string.

   #+BEGIN_SRC python
   >>> input("Enter a number: ")
   Enter a number: 3
   3
   >>> raw_input("Enter a number: ")
   Enter a number: 3
   '3'
   #+END_SRC

   *I just thought the numbers in Python are treated as expressions but strings are not, so the
   /raw_input/ is much more like input a string directly otherwise would be treated as a variable.*

*** long strings, raw strings, and unicode

**** long strings

     If you want to write a really long string, one that spans several lines, you can use triple
     quotes instead of ordinary quotes.

     *Tip:*
     Ordinary strings can span several lines only if  the last character on a line is a backslash.

**** raw strings

     *Raw strings* is useful when you trying to input a long pathname, like this:

     #+BEGIN_SRC python
     path = 'C:\\Programm Files\\fnord\\foo\\bar\\baz\\frozz\\bozz'
     #+END_SRC

     which with lots of backslashes. Here is using raw string:

     #+BEGIN_SRC python
     path = r'C:\Program Files\fnord\foo\bar\baz\frozz\bozz'
     #+END_SRC

     The last character in a raw string cannot be a backslash unless you escape it(and then the
     backslash you use to escape it will be part of the string, too). What if you want the last
     character in raw string to be a backslash?

     #+BEGIN_SRC python
     path = r'C:\Program Files\fnord\foo\bar\baz\frozz\bozz' '\\'
     #+END_SRC

**** unicode strings

     #+BEGIN_SRC python
     u'hello, world'
     #+END_SRC

     *Note:* In Python 3.0, all strings will be Unicode strins.

** new functions by now

   |--------------------------+------------------------------------------------------------|
   | function                 | description                                                |
   |--------------------------+------------------------------------------------------------|
   | abs(number)              | Returns teh absolute value of a number                     |
   |--------------------------+------------------------------------------------------------|
   | cmath.sqrt(number)       | Returns the square root; works with negative numbers       |
   |--------------------------+------------------------------------------------------------|
   | float(object)            | Converts a string or number to a floating-point number     |
   |--------------------------+------------------------------------------------------------|
   | help()                   | Offers interactive help                                    |
   |--------------------------+------------------------------------------------------------|
   | input(prompt)            | Gets input from the user                                   |
   |--------------------------+------------------------------------------------------------|
   | int(object)              | Converts a string or number to an integer                  |
   |--------------------------+------------------------------------------------------------|
   | long(object)             | Converts a string or number to a long integer              |
   |--------------------------+------------------------------------------------------------|
   | math.ceil(number)        | Returns the ceiling of a number as a float                 |
   |--------------------------+------------------------------------------------------------|
   | math.floor(number)       | Returns the floor of a number as a float                   |
   |--------------------------+------------------------------------------------------------|
   | math.sqrt(number)        | Return the square root; doesn't work with negative numbers |
   |--------------------------+------------------------------------------------------------|
   | pow(x, y[, z])           | Return s x to the power of y(modulo z)                     |
   |--------------------------+------------------------------------------------------------|
   | raw_input(prompt)        | Gets input from the user, as a string                      |
   |--------------------------+------------------------------------------------------------|
   | repr(object)             | Retrurns a string representation of a value                |
   |--------------------------+------------------------------------------------------------|
   | round(number[, ndigits]) | Rounds a number to a given precision                       |
   |--------------------------+------------------------------------------------------------|
   | str(object)              | Converts a value to string                                 |
   |--------------------------+------------------------------------------------------------|
* Lists and Tuples

   The most basic data structure in Python is the *sequence*. Each element of a
   sequence is assigned a number-its position, or /index/. The first index is
   zero, the second index is one, and so forth.

   *Note:* The last item of sequence is numbered -1, the next-to-last -2, and so
   forth. That means you can count forward /or/ backward from the first element,
   which lies at the beginning, or 0.

** sequence overview

   Python has siz built-in types of sequences. They are *lists*, *tuples*,
   *strings*, *Unicode strings*, *buffer objects* and *xrange objects*.

   The main difference between lists and tuples is that you can change a list,
   but you can't change a tuple.

   #+BEGIN_SRC python
   >>> edward = ['Edward Gumby', 42]
   #+END_SRC

   Swquences can contain other sequences, too.

   #+BEGIN_SRC python
   >>> edward = ['Edward Gumby', 42]
   >>> john = ['Jhon Smith', 50]
   >>> database = [edward, john]
   >>> database
   [['Edward Gumby', 42], ['John Smith', 50]]
   #+END_SRC

*** common sequence operations

    These operations include /indexin/, /slicig/, /adding/, /multiplying/,
    /iteration/ and checking for /membership/. In addtion, Python has built-in
    functions for finding the length of a sequence, and for finding its largest
    and smallest elements.

    To iterate over a sequence means to perform certain actions repeatedly, once
    per element in the sequence.

**** indexing

     All elements in a sequence are numbered—from zero and upwards. You can access
     them individually with a number, just like an array.

     *Note:* A string is just a sequence of characters.

     If a function call returns a sequence, you can index it directly. For instance,
     if you are simply interested in the fourth digit in a year entered by the user,
     you could do something like this:

     #+BEGIN_SRC python
     >>> fourth = raw_input('Year: ')[3]
     Year: 2005
     >>> fourth
     '5'
     #+END_SRC

     [[file:examples/indexing.py][Example]]

**** slicing

     You can use /slicing/ to access ranges of elements. Do this by using /two/ indices,
     separated by a colon:

     #+BEGIN_SRC python
     >>> tag = '<a href="http://www.python.org">Python web site</a>'
     >>> tag[9:30]
     'http://www.python.org'
     >>> tag[32:-4]
     'Python web site'
     #+END_SRC

     The /first/ index is the number of the first element you want to include. However,
     the /last/ index is the number of the first element /after/ your slice.
     In short, you supply two indices as limits for your slice, where the first is
     *inclusive* and the second is *exclusive*.

     #+BEGIN_SRC python
     >>> numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
     >>> numbers[3:6]
     [4, 5, 6]
     >>> numbers[-3:]
     [8, 9, 10]
     >>> numbers[:3]
     [1, 2, 3]
     >>> numbers[:]
     [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
     #+END_SRC

     [[file:examples/slicing.py][Example]]

***** longer steps

      When slicing, you specify (either explicitly or implicitly) the start and end points
      of the slice. Another parameter which normally is left implicit, is the step length.
      In a regular slice, the step length is one, which means that the slice “moves” from
      one element to the next, returning all the elements between the start and end:

      #+BEGIN_SRC python
      >>> numbers[0:10:1]
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
      >>> numbers[0:10:2]
      [1, 3, 5, 7, 9]
      #+END_SRC

      Still can use the shortcuts mentioned earlier.

      #+BEGIN_SRC python
      >>> numbers[::4]
      [1, 5, 9]
      #+END_SRC

      Naturally, the step size can't be zero, but it can be negative, which means extracting
      the elements form right to left:

      #+BEGIN_SRC python
      >>> numbers[8:3:-1]
      [9, 8, 7, 6, 5]
      #+END_SRC

**** adding sequences

     Sequences can be concatenated with the addition(plus) operator:

     #+BEGIN_SRC python
     >>> 'Hello, ' + 'world!'
     'Hello, world!'
     #+END_SRC

     But, you can’t concatenate a list and a string, although both are sequences. In general,
     you cannot concatenate sequences of different types.

**** multiplication

     Multiplying a sequence by a number x creates a new sequence where the original sequence is
     repeated x times:

     #+BEGIN_SRC python
     >>> 'python' * 5
     'pythonpythonpythonpythonpython'
     >>> [42] * 10
     [42, 42, 42, 42, 42, 42, 42, 42, 42, 42]
     #+END_SRC

***** none, empty lists, and initialization

      An empty list is simply written as two brackets ([]) - there's nothing in it. None is a
      Python value and means exactly that—"nothing here". So if you want to initialize a list
      of length 10, you could do the following:

      #+BEGIN_SRC python
      >>> sequence = [None] * 10
      >>> sequence
      [None, None, None, None, None, None, None, None, None, None]
      #+END_SRC

      [[file:examples/sequence_multiplication.py][Example]]

**** membership

     To check whether a value can be found in a sequence, you use the *in* operator.
     It checks whether something is true and returns a value accordingly: True for
     true and False for false.

     #+BEGIN_SRC python
     >>> permissions = 'rw'
     >>> 'w' in permissions
     True
     >>> 'x' in permissionsCHAPTER 2 ■ LISTS AND TUPLES
     False
     >>> users = ['mlh', 'foo', 'bar']
     >>> raw_input('Enter your user name: ') in users
     Enter your user name: mlh
     True
     >>> subject = '$$$ Get rich now!!! $$$'
     >>> '$$$' in subject
     True
     #+END_SRC

     [[file:examples/sequence_membership.py][Example]]

**** length, minimum, and maximum

     #+BEGIN_SRC python
     >>> numbers = [100, 34, 678]
     >>> len(numbers)
     3
     >>> max(numbers)
     678
     >>> min(numbers)
     34
     >>> max(2, 3)
     3
     >>> min(9, 3, 2, 5)
     2
     #+END_SRC

*** lists

    list are /mutable/ - that is, you can change their contents - and they have
    many useful specialized methods.

**** function

     #+BEGIN_SRC python
     >>> list('Hello')
     ['H', 'e', 'l', 'l', 'o']
     #+END_SRC

     *list* works with all kinds of sequences, not just strings.

     *Tip:* To convert a list of characters such as the preceding code back to
     string, you would use the following expression:

     #+BEGIN_SRC python
     ''.join(somelist)
     #+END_SRC

     where some list is you list.

**** basic operations

     You can perform all the standard sequence operations on lists.

***** changing lists: item assignments

      #+BEGIN_SRC python
      >>> x = [1, 1, 1]
      >>> x[1] = 2
      >>> x
      [1, 2, 1]
      #+END_SRC

      *Note:* You cannot assign to a postion that doesn't exist.

***** deleting elements

      You can simply use the *del* statement:

      #+BEGIN_SRC python
      >>> names = ['Alice', 'Beth', 'Cecil', 'Dee-Dee', 'Earl']
      >>> del names[2]
      >>> names
      ['Alice', 'Beth', 'Dee-Dee', 'Earl']
      #+END_SRC

***** assigning to slices

      #+BEGIN_SRC python
      >>> name = list('Perl')
      >>> name
      ['P', 'e', 'r', 'l']
      >>> name[2:] = list('ar')
      >>> name
      ['P', 'e', 'a', 'r']
      #+END_SRC

      You can assign to several positions at once.

      #+BEGIN_SRC python
      >>> name = list('Perl')
      >>> name[1:] = list('ython')
      >>> name
      ['P', 'y', 't', 'h', 'o', 'n']
      #+END_SRC

      Slice assignments can even be used to insert elements without replacing any of the
      original ones:

      #+BEGIN_SRC python
      >>> numbers = [1, 5]
      >>> numbers[1:1] = [2, 3, 4]
      >>> numbers
      [1, 2, 3, 4, 5]
      #+END_SRC

***** list methods

      A method is a function that is tightly coupled to some object, be it a list, a number,
      a string, or whatever. In general, a method is called like this:

      object.method(arguments)

      A method call looks just like a function call, except that the object is put before the
      method name, with a dot separating them.

****** append

       The *append* method is used to append an object to the end of a list:

       #+BEGIN_SRC python
       >>> lst = [1, 2, 3]
       >>> lst.append(4)
       >>> lst
       [1, 2, 3, 4]
       #+END_SRC

****** count

       The *count* method counts the occurrences of an element in a list:
       #+BEGIN_SRC python
       >>> ['to', 'be', 'or', 'not', 'to', 'be'].count('to)
       2
       >>> x = [[1, 2], 1, 1, [2, 1, [1, 2]]]
       >>> x.count(1)
       2
       #+END_SRC

****** extend

       The *extend* method allows you to append several values at once by supplying
       a sequence of the values you want to append. In other words, your original
       list has been extended by the other one:

       #+BEGIN_SRC python
       >>> a = [1, 2, 3]
       >>> b = [4, 5, 6]
       >>> a.extend(b)
       >>> a
       [1, 2, 3, 4, 5, 6]
       #+END_SRC

       This may seem similar to concatenation, but the important difference is that the
       extended sequence(in this case, a) is modified. This is not the case in ordinary
       concatenation, in which a completely new sequence is returned;

       #+BEGIN_SRC python
       >>> a = [1, 2, 3]
       >>> b = [4, 5, 6]
       >>> a + b
       [1, 2, 3, 4, 5, 6]
       >>> a
       [1, 2, 3]
       #+END_SRC

****** index

       The *index* method is used for searching lists to find the index of the first
       occurrence of a value:

       #+BEGIN_SRC python
       >>> knights = ['We', 'are', 'the', 'knights', 'who', 'say', 'ni']
       >>> knights.index('who')
       4
       #+END_SRC

****** insert

       The *insert* method is used to insert an object into a list:

       #+BEGIN_SRC python
       >>> numbers = [1, 2, 3, 5, 6, 7]
       >>> numbers.insert(3, 'four')
       >>> numbers
       [1, 2, 3, 'four', 5, 6, 7]
       #+END_SRC

****** pop

       The *pop* method removes an element(by default, the last one) from the list
       and returns it:

       #+BEGIN_SRC python
       >>> x = [1, 2, 3]
       >>> x.pop()
       3
       >>> x
       [1, 2]
       >>> x.pop(0)
       1
       >>> x
       [2]
       #+END_SRC

****** remove

       The *remove* method is used to remove the first occurence of a value:

       #+BEGIN_SRC python
       >>> x = ['to', 'be', 'or', 'not', 'to', 'be']
       >>> x.remove('be')
       >>> x
       ['to', 'or', 'not', 'to', 'be']
       #+END_SRC

****** reverse

       The *reverse* method reverses the elements in the list.

       #+BEGIN_SRC python
       >>> x = [1, 2, 3]
       >>> x.reverse()
       >>> x
       [3, 2, 1]
       #+END_SRC

       *Tip:* If you want to iterate over a sequence in reverse, you can use the
       reversed function. This function doesn’t return a list, though; it returns
       an iterator. You can convert the returned object with list :

       #+BEGIN_SRC python
       >>> x = [1, 2, 3]
       >>> list(reversed(x))
       [3, 2, 1]
       #+END_SRC

****** sort

       The *sort* method is used to sort lists in place. Sorting "in place" means
       changing the original list so its elements are in sorted order, rather than
       simply returning a sorted copy of the list:

       #+BEGIN_SRC python
       >>> x = [4, 6, 2, 1, 7, 9]
       >>> x.sort()
       >>> x
       [1, 2, 4, 6, 7, 9]
       #+END_SRC

       You’ve encountered several methods already that modify the list without returning any-
       thing, and in most cases that behavior is quite natural (as with append, for example).
       But I want to emphasize this behavior in the case of sort because so many people seem
       to be confused by it. The confusion usually occurs when users want a sorted copy of a
       list while leaving the original alone. An intuitive (but wrong) way of doing this is
       as follows:

       #+BEGIN_SRC python
       >>> x = [4, 6, 2, 1, 7, 9]
       >>> y = x.sort() # Don't do this!
       >>> print y
       None
       #+END_SRC

       Because sort modifies x but returns nothing, you end up with a sorted x and a y
       containing None. One correct way of doing this would be to first bind y to a copy
       of x, and then sort y, as follows:

       #+BEGIN_SRC python
       >>> x = [4, 6, 2, 1, 7, 9]
       >>> y = x[:]
       >>> y.sort()
       >>> x
       [4, 6, 2, 1, 7, 9]
       >>> y
       [1, 2, 4, 6, 7, 9]
       #+END_SRC

       Recall that x[:] is a slice containing all the elements of x, effectively a copy of
       the entire list. Simply assigning x to y wouldn’t work because both x and y would
       refer to the same list:

       #+BEGIN_SRC python
       >>> y = x
       >>> y.sort()
       >>> x
       [1, 2, 4, 6, 7, 9]
       >>> y
       [1, 2, 4, 6, 7, 9]
       #+END_SRC

       Another way of getting a sorted copy of a list is using the *sorted* function:

       #+BEGIN_SRC python
       >>> x = [4, 6, 2, 1, 7, 9]
       >>> y = sorted(x)
       >>> x
       [4, 6, 2, 1, 7, 9]
       >>> y
       [1, 2, 4, 6, 7, 9]
       #+END_SRC

*** tuples: immutables sequences

    Tuples are sequences, just like lists. The only difference is that tuples can’t be
    changed. (As you may have noticed, this is also true of strings.) The tuple syntax
    is simple—if you separate some values with commas, you automatically have a tuple:

    #+BEGIN_SRC python
    >>> 1, 2, 3
    (1, 2, 3)
    #+END_SRC

    tuples may also be (and often are) enclosed in parentheses:

    #+BEGIN_SRC python
    >>> (1, 2, 3)
    (1, 2, 3)
    #+END_SRC

    This is a bit peculiar-you have to include a comma, even though there is
    only one value:

    #+BEGIN_SRC python
    >>> 42
    42
    >>> 42,
    (42,)
    >>> (42,)
    (42,)
    #+END_SRC

    The last two examples produce tuples of length one, while the first is not a
    tuple at all. The comma is crucial. Simply adding parentheses won’t help: (42)
    is exactly the same as 42. One lonely comma, however, can change the value of
    an expression completely:

    #+BEGIN_SRC python
    >>> 3*(40+2)
    126
    >>> 3*(40+2,)
    (42, 42, 42)
    #+END_SRC

**** function

     The tuple function works in pretty much the same way as list: it takes one sequence argument
     and converts it to a tuple. If the argument is already a tuple, it is returned unchanged:

     #+BEGIN_SRC python
     >>> tuple([1, 2, 3])
     (1, 2, 3)
     >>> tuple('abc')
     ('a', 'b', 'c')
     >>> tuple((1, 2, 3))
     (1, 2, 3)
     #+END_SRC

** new functions

   |---------------+-------------------------------------------------------|
   | function      | description                                           |
   |---------------+-------------------------------------------------------|
   | cmp(x, y)     | Compares two values                                   |
   |---------------+-------------------------------------------------------|
   | len(seq)      | Returns the length of a sequence                      |
   |---------------+-------------------------------------------------------|
   | list(seq)     | Converts a sequence to a list                         |
   |---------------+-------------------------------------------------------|
   | max(args)     | Returns the maximum of a sequence or set of arguments |
   |---------------+-------------------------------------------------------|
   | min(args)     | Returns the minimum of a sequence or set of arguments |
   |---------------+-------------------------------------------------------|
   | reversed(seq) | Lets you iterate over a sequence in reverse           |
   |---------------+-------------------------------------------------------|
   | sorted(seq)   | Returns a sorted list of the elements of seq          |
   |---------------+-------------------------------------------------------|
   | tuple(seq)    | Converts a sequence to a tuple                        |
   |---------------+-------------------------------------------------------|

* Strings

** basic operations

   All the standard sequence operations(indexing, slicing, multiplication,
   membership, length, minimum, and maximum) work with strings. Strings are
   immutable, so all kinds of item or slice assignments are illegal:

   #+BEGIN_SRC python
   >>> website = 'http://www.python.org'
   >>> website[-3:] = 'com'
   Traceback (most recent call last):
     File "<pyshell#19>", line 1, in ?
       website[-3:] = 'com'
   TypeError: object doesn't support slice assignment
   #+END_SRC

** string formatting: the short version

   String formatting uses the (aptly named) string formatting operator, the
   percent (%) sign. To the left of the %, you place a string (the format string);
   to the right of it, you place the value you want to format.

   #+BEGIN_SRC python
   >>> format = "Hello, %s. %s enough for ya?"
   >>> values = ('world', 'Hot')
   >>> print format % values
   Hello, world. Hot enough for ya?
   #+END_SRC

   *Note:* If you use a list or some other sequence instead of a tuple, the sequence
   will be interpreted as single value. Only tuples and dictionaries will allow you
   to format more than one value.

   The %s parts of the format string are called /conversion specifiers/. They mark the
   places where the values are to be inserted.

*** template strings

    The string module offers another way of formatting values: template strings. They
    work more like variable substitution in many UNIX shells, with $foo being replaced
    by a keyword argument called foo, which is passed to the template method substitute:

    #+BEGIN_SRC python
    >>> from string import Template
    >>> s = Template('$x, glorious $x!')
    >>> s.substitute(x='slurm')
    'slurm, glorious slurm!'
    #+END_SRC

    If the replacement field is part of a word, the name must be enclosed in braces, in
    order to clearly indicate where it ends:

    #+BEGIN_SRC python
    >>> s = Template("It's ${x}tastic!")
    >>> s.substitute(x='slurm')
    "It's slurmtastic!"
    #+END_SRC

    In order to insert a dollar sign, use $$:

    #+BEGIN_SRC python
    >>> s = Template("Make $$ selling $x!")
    >>> s.substitute(x='slurm')
    'Make $ selling slurm!'
    #+END_SRC

    Instead of using keyword arguments, you can supply the value-name pairs in a dictionary:

    #+BEGIN_SRC python
    >>> s = Template('A $thing must never $action.')
    >>> d = {}
    >>> d['thing'] = 'gentleman'
    >>> d['action'] = 'show his socks'
    >>> s.substitute(d)
    'A gentleman must never show his socks.'
    #+END_SRC

    There is also a method called safe_substitute that will not complain about
    missing values or incorrect uses of the $ character.

** string formatting: the long version

*** conversion specifier

    A basic conversion specifier consists of the items that follow. Note that the order
    of these items is crucial.

    * *The % character:* This marks the beginning of the conversion specifier.
    * *Conversion flags:* These are optional and may be -, indicating left alignment;
      +, indicating that a sign should precede the converted value; " "(a space character),
      indicating that space should precede positive numbers; or 0, indicating that the
      conversion should be zero-padded.
    * *The minimum field width:* This is also optional and specifies that the converted
      string will be at least this wide. If this is an * (asterisk), the width will be
      read from the value tuple.
    * *A . (dot) followed by the precision:* This is also optional. If a real number is
      converted, this many decimals should be shown. If a string is converted, this number
      is the /maximum field width/. If this is an * (asterisk), the precision will be read
      from the value tuple.
    * *The conversion type:* This can be any of the types listed follow.

    |-----------------+------------------------------------------------------------------------------|
    | conversion type | meaning                                                                      |
    |-----------------+------------------------------------------------------------------------------|
    | d, i            | signed integer decimal                                                       |
    |-----------------+------------------------------------------------------------------------------|
    | o               | unsigned octal                                                               |
    |-----------------+------------------------------------------------------------------------------|
    | u               | unsigned decimal                                                             |
    |-----------------+------------------------------------------------------------------------------|
    | x               | unsigned hexadecimal(lowercase)                                              |
    |-----------------+------------------------------------------------------------------------------|
    | X               | unsigned hexadecimal(uppercase)                                              |
    |-----------------+------------------------------------------------------------------------------|
    | e               | floating-point exponential format(lowercase)                                 |
    |-----------------+------------------------------------------------------------------------------|
    | E               | floating-point exponential format(uppercase)                                 |
    |-----------------+------------------------------------------------------------------------------|
    | f, F            | floating-point decimal format                                                |
    |-----------------+------------------------------------------------------------------------------|
    | g               | same as e if exponent is greater than -4 or less than precision; f otherwise |
    |-----------------+------------------------------------------------------------------------------|
    | G               | same as E if exponent is greater than -4 or less than precision; F otherwise |
    |-----------------+------------------------------------------------------------------------------|
    | c               | single character(accepts an integer or a single character string)            |
    |-----------------+------------------------------------------------------------------------------|
    | r               | string(converts any Python object using repr)                                |
    |-----------------+------------------------------------------------------------------------------|
    | s               | string(converts any Python object using str)                                 |
    |-----------------+------------------------------------------------------------------------------|

*** signs, alignment, and zero-padding

    Before the width and precision numbers, you may put a "flag", which may be either
    zero, plus, minus, or blank. A zero means that the number will be zero-padded:

    #+BEGIN_SRC python
    >>> ‘%010.2' % pi
    '00000003.14'
    #+END_SRC

    A minus sign(-) left-aligns the value:

    #+BEGIN_SRC python
    >>> '%-10.2f' % pi
    '3.14       '
    #+END_SRC

    A blank(" ") means that a blank should be put in front of positive numbers. This
    is useful for aligning positive and negative numbers:

    #+BEGIN_SRC python
    >>> print (' %5d' % 10)
       10
    >>> print ('% 5d' % -10)
      -10
    #+END_SRC

    A plus(+) means that a sign(either plus or minus) should precede both positive
    and negative numbers (again, useful for aligning):

    #+BEGIN_SRC python
    >>> print ('%+5d' % 10) + ('%+5d' % 10)
      +10
      -10
    #+END_SRC

    In the following example, use the asterisk width specifier to format a table of fruit
    prices, where the user enters the total width of the table. [[file:./examples/string_fromatting.py][Example]]

*** string methods

**** find

     The *find* method finds a substring within a larger string. Ite returns
     the leftmost index where the substring is found. If it is /not/ found,
     -1 is returned:

     #+BEGIN_SRC python
     >>> 'With a moo-moo here, and a moo-moo there'.find('moo')
     7
     >>> title = "Monty Python's Flying Circus"
     >>> title.find('Monty')
     0
     >>> title.find('Zirquss')
     -1
     #+END_SRC

     You may also supply a starting point for search and, optionally, an ending point:

     #+BEGIN_SRC python
     >>> subject = '$$$ Get rich now!!! $$$'
     >>> subject.find('$$$')
     0
     >>> subject.find('$$$', 1) #only supplying the start
     20
     >>> subject.find('!!!')
     16
     >>> subject.find('!!!', 0, 16) # supplying start and end
     -1
     #+END_SRC

**** join
     The *join* method is the inverse of *split*. It is use to join the elements of a
     sequence:

     #+BEGIN_SRC python
     >>> seq = [1, 2, 3, 4, 5]
     >>> sep = '+'
     >>> sep.join(seq) # trying to join a list of numbers
     Traceback (most recent call last):
       File "<stdin>", line 1, in ?
     TypeError: sequence item 0: expected string, int found
     >>> seq = ['1', '2', '3', '4', '5']
     >>> sep.join(seq) # joining a list of strings
     '1+2+3+4+5'
     >>> dirs = '', 'usr', 'bin', 'env'
     >>> '/'.join(dirs)
     '/usr/bin/env'
     >>> print 'C:' + '\\'.join(dirs)
     'C:\usr\bin\env'
     #+END_SRC

     *join into is much proper*

**** lower

     The *lower* method returns a lowercase version of the string:

     #+BEGIN_SRC python
     >>> 'Traditional STYLE'.lower()
     'traditional style'
     #+END_SRC

***** title casing

      One relative of *lower* is the *title* method, which title cases a string - that
      is, all words start with uppercase characters, and all other characters are
      lowercased.

      #+BEGIN_SRC python
      >>> "this's all folks".title()
      "That'S All, Folks"
      #+END_SRC

      An alternative is the *capwords* function from the *string* module:

      #+BEGIN_SRC python
      >>> import string
      >>> string.capwords("that's all, folks")
      "That's All, Folks"
      #+END_SRC

**** replace

     The *replace* method returns a string where all the occurrences of one
     string have been replaced by another:

     #+BEGIN_SRC python
     >>> 'This is a test'.replace('is', 'eez')
     'Theez eez a test'
     #+END_SRC

**** split

     A very important string method, *split* is the inverse of *join*, and is used
     to *split* a string into a sequence:

     #+BEGIN_SRC python
     >>> '1+2+3+4+5'.split('+')
     ['1', '2', '3', '4', '5']
     >>> 'usr/bin/env'.split('/')
     ['', 'usr', 'bin', 'env']
     >>> 'Using the default'.split()
     ['Using', 'the', 'default']
     #+END_SRC

     If no separator is supplied, the default is to split on all runs of consecutive
     whitespace characters(spaces, tabs, newlines, and so on).

     *split by is much proper*

**** strip

     The *strip* method returns a string where whitespace on the left and right (but
     not internally) has been stripped (removed):

     #+BEGIN_SRC python
     >>> '        internal whitespace is kept        '.strip()
     'internal whitespace is kept'
     #+END_SRC

**** translate

     Similar to *replace*, *translate* replaces parts of a string, but unlike *replace*,
     *translate* works only with single characters. Its strength lies in that it can
     perform several replacements simultaneously, and can do so more efficiently than
     *replace*.

     Before you can use *translate*, you must make a /translation table/. This translation
     talbe is full listing of which characters should be replaced by which and, you won't
     write it out yourself. Instead, you'll use the function *maketrans* form the *string*
     module.

     The *maketrans* function takes two arguments: two strings of equal length, indicating
     that each character in the first string should be replaced by the character in the
     same postion in the second string.

     #+BEGIN_SRC python
     >>> from string import maketrans
     >>> table = maketrans('cs', 'kz')
     #+END_SRC

     A translation table is a string containing one replacement letter for each of the
     256 characters in the ASCII character set:

     #+BEGIN_SRC python
     >>> table = maketrans('cs', 'kz')
     >>> len(table)
     256
     >>> table[97:123]
     'abkdefghijklmnopqrztuvwxyz'
     >>> maketrans('', '')[97:123]
     'abcdefghijilmnopqrstuvwxyz'
     #+END_SRC

     The empty translation has a normal alphabet, while in the preceding code, the letter c
     has been replaced by k, and s has been replaced by z.

     #+BEGIN_SRC python
     >>> 'this is an incredible test'.translate(table)
     'thiz iz an inkredible tezt'
     #+END_SRC

*** new function

    |----------------------------+-------------------------------------------------------------------------------------|
    | function                   | description                                                                         |
    |----------------------------+-------------------------------------------------------------------------------------|
    | string.capwords(s[, sep])  | splits *s* with *split* (using sep), capitalize items, and join with a single space |
    |----------------------------+-------------------------------------------------------------------------------------|
    | string.maketrans(from, to) | makes a translation table for *tanslate*                                            |
    |----------------------------+-------------------------------------------------------------------------------------|

* Dictionaries

** creating and using dictionaries

   Dictionaries consist of pairs (called /items/) of /keys/ and their corresponding
   /values./ Each key is separated form its value by a colon(:), the items are seperated
   by commas, and the whole thing is enclosed in curly braces. An empty dictionary
   (without any items) is written just two curly bracws, like this {}.

   *Note:* Keys are unique within a dictionary (and any other kind of mapping). Values
   do not need to be unique within a dictionary.

** the *dict* function

   You can use the *dict* function to construct dictionaries from other mappings or from
   sequences of (key, value) pairs:

   #+BEGIN_SRC python
   >>> item = [('name', 'Gumby'), ('age', 42)]
   >>> d = dict(item)
   >>> d
   {'age': 42, 'name': 'Gumby'}
   >>> d['name']
   'Gumby'
   #+END_SRC

   It can also be used with /keyword arguments/, as follows:

   #+BEGIN_SRC python
   >>> d = dict(name='Gumby', age=42)
   >>> d
   {'age': 42, 'name': 'Gumby'}
   #+END_SRC

** basic dictionary operations

   * *len(d)*  returns the number of items (key-value pairs) in *d*.
   * *d[k]* returns the value associated with the key *k*.
   * *d[k] = v* associates the value *v* with the key *k*.
   * *del d[k]* deletes the item with key *k*.
   * *k in d* checks whether there is an item in *d* that has the key *k*.

   Distinctions between dictionaries and lists:

   *Key types:* Dictionary keys don't have toe be integers(though they may be).
   They may be immutable type, such as floating-point(real)numbers, strings, or tuples.

   *Automatic addition:* You can assign a value to a key, even if that key isn't in
   the dictionary to begin with; in that case, a new item will be created. You
   cannot assign a value to an index outside the list's range(without using *append*
   or something like that).

   *Membership:* The expression *k in d*(where *d* is a dictionary)looks for a /key/,
   not a /value/. The expression *v in l*, on the other hand(where *l* is a list)looks
   for a /value/, not an /index/.

   [[file:./examples/dictionary.py][Dictionary Example]]

** string formatting with dictionaries

   If you use a dictionary(with only string and keys) instead of a tuple, you can maek
   the string formatting even snazzier. After the % character in each conversion specifier,
   you add a key(enclosed in parentheses), which is followed by the other specifier elements:

   #+BEGIN_SRC python
   >>> phonebook
   {'Beth': '9102', 'Alice': '2341', 'Ceile': '3258'}
   >>> "Cecil's phone number is %(Cecil)s." % phonebook
   "Cecil's phone number is 3258."
   #+END_SRC

   Using it in template:

   #+BEGIN_SRC python
   >>> template = '''<html>
        <head><title>%(title)s</title></head>
        <body>
        <h1>%(title)s</h1>
        <p>%(text)s</p>
        </body>'''
   >>> data = {'title': 'My Home Page', 'text': 'Welcome to my home page!'}
   >>> print template % data
   <html>
   <head><title>My Hone Page</title></head>
   <body>
   <h1>My Home Page</h1>
   <p>Welcome to my home page!</p>
   </body>
   #+END_SRC

** methods

*** clear

    The *clear* method removes all items from the dictionary. This is an in-place
    operation(like *list.sort*), so it returns nothing(or, rather, *None*):

    #+BEGIN_SRC python
    >>> d = {}
    >>> d['name'] = 'Phill'
    >>> d['age'] = 42
    >>> d
    {'age': 42, 'name': 'Phill'}
    >> returned_value = d.clear()
    >>> d
    {}
    >>> print returned_value
    None
    #+END_SRC

*** copy

    The *copy* method returns a new dictonary with the same key-value pairs(a shallow
    copy, since the values themselves are the /same/, not copies):

    #+BEGIN_SRC python
    >>> x = {'username': 'admin', 'machines': ['foo', 'bar', 'baz']}
    >>> y = x.copy()
    >>> y['username'] = 'mlh'
    >>> y['machines'].remove('bar')
    >>> y
    {'username': 'mlh', 'machines': ['foo', 'baz']}
    >>> x
    {'username': 'admin', 'machines': ['foo', 'baz']}
    #+END_SRC

    When you replace a value in the copy, the original is unaffected. However, if
    you /modify/ a value (in place, without replacing it), the original is changed
    as well because the same value is stored there (like the 'machines' list in this
    example).

    One way to avoid that problem is to make a *deep copy*, you accomplish this using
    the function *deepcopy* from the copy module:

    #+BEGIN_SRC python
    >>> from copy import deepcopy
    >>> d = {}
    >>> d['names'] = ['Alfred', 'Bertrand']
    >>> c = d.copy()
    >>> dc = deepcopy(d)
    >>> d['names'].append('Clive')
    >>> c
    {'names': ['Alfred', 'Bertrand', 'Clive']}
    >>> dc
    {'names': ['Alfred', 'Bertrand']}
    #+END_SRC

*** fromkeys

    The *fromkeys* method creates a new dictionary with the given keys, each with a
    default corresponding value of *None*:

    #+BEGIN_SRC pyhon
    >>> {}.fromkeys(['name', 'age'])
    {'age': None, 'name': None}
    #+END_SRC

    Instead, you can call the method directly on dict, which (as mentioned before)
    is the type of all dictionaries.

    #+BEGIN_SRC python
    >>> dict.fromkeys(['name', 'age'])
    {'age': None, 'name': None}
    #+END_SRC

    If you don’t want to use None as the default value, you can supply your own default:
    #+BEGIN_SRC python
    >>> dict.fromkeys(['name', 'age'], '(unknown)')
    {'age': '(unknown)', 'name': '(unknown)'}
    #+END_SRC

*** get

    The *get* method is a forgiving way of a accessing dictionary items. Ordinarily,
    when you try to access an item that is not present in the dictionary, things go
    very wrong:

    #+BEGIN_SRC python
    >>> d = {}
    >>> print d['name']
    Traceback (most recent call last):
      File "<stdin>", line 1, in ?
    KeyError: 'name'
    #+END_SRC

    Not so with get:

    #+BEGIN_SRC python
    Not so with get:
    >>> print d.get('name')
    None
    #+END_SRC

    As you can see, when you use get to access a nonexistent key, there is no exception.
    Instead, you get the value None. You may supply your own “default” value, which is
    then used instead of None:

    #+BEGIN_SRC python
    >>> d.get('name', 'N/A')
    'N/A'
    #+END_SRC

    If the key is there, get works like ordinary dictionary lookup:

    #+BEGIN_SRC python
    >>> d['name'] = 'Eric'
    >>> d.get('name')
    'Eric'
    #+END_SRC
    [[file:./examples/dictionary_method.py][Dictionary Method Example]]

*** has_key

    The *has_key* method checks whether a dictionary has a given key. The
    expression *d.has_key(k)* is euivalent to *k in d*.

    #+BEGIN_SRC python
    >>> d = {}
    >>> d.has_key('name')
    False
    >>> d['name'] = 'Eric'
    >>> d.has_key('name')
    True
    #+END_SRC

*** items and iteritems

    The *items* method returns all the items of the dictionary as a list of
    items in which each item is of the form(key, value). The items are not
    returnd in any particular order:

    #+BEGIN_SRC python
    >>> d = {'title': 'Python Web Site', 'url': 'http://www.python.org', 'spam': 0}
    >>> d.items()
    [('url', 'http://www.python.org'), ('spam', 0), ('title', 'Python Web Site')]
    #+END_SRC

    The *iteritems* method works in much the same way, but returns an /iterator/
    instead of a list:

    #+BEGIN_SRC python
    >>> it = d.iteritems()
    >>> it
    <dictionary-iterator object at 0x7ff15c3c35d0>
    >>> list(it) # Convert the iterator to a list
    [('url', 'http://www.python.org'), ('spam', 0), ('title', 'Python Web Site')]
    #+END_SRC

*** keys and iterkeys

    The *keys* method returns a list of the keys in the dictionary, while *iterkeys*
    returns an iterator over the keys.

*** pop

    The *pop* method can be used to get the value corresponding to a given key, and
    then remove the key-value pair from the dictionary:

    #+BEGIN_SRC python
    >>> d = {'x': 1, 'y': 2}
    >>> d.pop('x')
    1
    >>> d
    {'y': 2}
    #+END_SRC

*** popitem

    The *popitem* method is similar to *list.pop*, which pops off the last
    element of a list. Unlike *list.pop*, however *popitem* pops off an arbirary
    item because dictionaries don't have a "last element" or any order whatsoever.
    This may be very useful if you want to remve and process the items one by one
    in an efficient way(without retrieving a list of the keys first):

    #+BEGIN_SRC python
    >>> d
    {'url': 'http://www.python.org', 'spam': 0, 'title': 'Python Web Site'}
    >>> d.popitem()
    ('url', 'http://www.python.org')
    >>> d
    {'spam': 0, 'title': 'Python Web Site'}
    #+END_SRC

    Although *popitem* is similar to the list method *pop*, there is no dictionary
    equivalent of *append* (which adds an element to the end of a list).

*** setdefault

    The *setdefault* method is somewhat similar to *get*, in that it retrives a valve
    associated with a given key. In addition to the *get* functionality, *setdefault*
    /sets/ the value corresponding to the given key if it is not already in the
    dictionary:

    #+BEGIN_SRC python
    >>> d = {}
    >>> d.setdefault('name', 'N/A')
    'N/A'
    >>> d
    {'name': 'N/A'}
    >>> d['name'] = 'Gumby'
    >>> d.setdefault('name', 'N/A')
    'Gumby'
    >>> d
    {'name': 'Gumby'}
    #+END_SRC

    As you can see, when the key is missing, *setdefault* returns the default and updates
    the dictionary accordingly. If the key is present, its value is retruned and the
    dictionary is left unchanged. The defalut is optional, as with *get*; if it is left
    out, None is used.

*** update

    The *update* method updates one dictionary with the items of another:

    #+BEGIN_SRC python
    >>> d = {
           'title': 'Python Web Site',
           'url': 'http://www.python.org',
           'changed': 'Mar 14 22:09:15 MET 2008'
        }
    >>> x = {'title': 'Python Language Website'}
    >>> d.update(x)
    >>> d
    {'url': 'http://www.python.org', 'changed':
    'Mar 14 22:09:15 MET 2008', 'title': 'Python Language Website'}
    #+END_SRC

    The *update* method can be called in the same way as the *dict* function(or type
    constructor), as discussed earlier in this chapter. This means that *update* can be called
    with a mapping, a sequence(or other iterable object) of (key, value) pairs, or keyword
    arguments.

*** values and itervalues

    The *values* method returns a list of the values in the dictionary(and *itervalues*
    returns an iterator of the values). Unlike *keys*, the list returned by *values* may
    contain duplicates:

    #+BEGIN_SRC python
    >>> d = {}
    >>> d[1] = 1
    >>> d[2] = 2
    >>> d[3] = 3
    >>> d[4] = 1
    >>> d.values()
    [1, 2, 3, 1]
    #+END_SRC

** new functions

   |-----------+----------------------------------------------------------------------------|
   | function  | description                                                                |
   |-----------+----------------------------------------------------------------------------|
   | dict(seq) | creats diction from (key, value) pairs (or a mapping or keyword arguments) |
   |-----------+----------------------------------------------------------------------------|

* Conditionals, Loops, and some other statements

** printing with commas

   You can actually print more than one expression, as long as you separate
   them with commas:

   #+BEGIN_SRC python
   >>> print 'Age:', 42
   Age: 42
   #+END_SRC

   As you can see, a space character is inserted between each argument.
   *Note:* The arguments of *print* do /not/ form a tuple, as one might
   expect:

   #+BEGIN_SRC python
   >>> 1, 2, 3
   (1, 2, 3)
   >>> print 1, 2, 3
   1 2 3
   >>> print (1, 2, 3)
   (1, 2, 3)
   #+END_SRC

   If you add a comma at the end, your next print statement will continue
   printing on the same line. For example, the statements

   #+BEGIN_SRC python
   print 'Hello,',
   print 'world!'
   #+END_SRC

** importing something as something else

   Usually, when you import something from a module, you either use

   #+BEGIN_SRC python
   import somemodule
   #+END_SRC

   or

   #+BEGIN_SRC python
   from somemodule import somefunction
   #+END_SRC

   or

   #+BEGIN_SRC python
   from somemodule import somefunciton, anotherfunction, yetanotherfunction
   #+END_SRC

   or

   #+BEGIN_SRC python
   from somemodule import *
   #+END_SRC

   But what if you have two modules, each containing a function called
   *open*, for example--what do you do then? You could simply import the
   modules using the first form, and then use the functions as follows:

   #+BEGIN_SRC python
   module1.open(...)
   module2.open(...)
   #+END_SRC

   But there is another option: add an *as* clause to the end and supply
   the name you want to use, either for the entire module:

   #+BEGIN_SRC python
   >>> import math as foobar
   >>> foobar.sqrt(4)
   2.0
   #+END_SRC

   or for the given function:

   #+BEGIN_SRC python
   >>> from math import sqrt as foobar
   >>> foobar(4)
   2.0
   #+END_SRC

** assignment magic

*** sequence unpacking

   You can perform several different assignments /simultaneously/:

   #+BEGIN_SRC python
   >>> x, y, z = 1, 2, 3
   >>> print x, y, z
   1 2 3
   #+END_SRC

   Well, you can use it to switch the contents of two(or more) variables:

   #+BEGIN_SRC python
   >>> x, y = y, x
   >>> print x, y, z
   2 1 3
   #+END_SRC

   Here is called *sequence unpacking(or iterable unpacking)*. I have a
   sequence (or an arbitrary iterable object) of values, and I unpack it
   into a sequence of variables.

   #+BEGIN_SRC python
   >>> values = 1, 2, 3
   >>> values
   (1, 2, 3)
   >>> x, y, z = values
   >>> x
   1
   #+END_SRC

   This allows functions to return more than one value, packed as a tuple, easily
   accessible through a single assignment. The sequence you unpack must have exactly
   as many items as the targets you list on the left of the = sign; otherwise Python
   raises an exception when the assignment is performed:

   #+BEGIN_SRC python
   >>> x, y, z = 1, 2
   Traceback (most recent call last):
     File "<stdin>", line 1, in <module>
   ValueError: need more than 2 values to unpack
   >>> x, y, z = 1, 2, 3, 4
   Traceback (most recent call last):
     File "<stdin>", line 1, in <module>
   ValueError: too many values to unpack
   #+END_SRC

   *Note:* Python 3.0 has another unpacking feature: you can use the star operator(*),
   just as in function argument lists. For example, a, b, rest* = [1, 2, 3, 4] will result
   in *rest* gathering whatever remains after assigning calues to *a* and *b*. In
   this case, *reset* will be [3, 4].

*** chained assignments

    Chained assignments are used as a shortcut when you want to bind several variables
    to the same value. This may seem a bit like the simultaneous assignments, except
    that here you are dealing with only one value:

    #+BEGIN_SRC python
    x = y = somefunction()
    #+END_SRC

    which is the same as

    #+BEGIN_SRC python
    y = somefunction()
    x = y
    #+END_SRC

*** augemented assignments

    #+BEGIN_SRC python
    >>> x = 2
    >>> x += 1
    >>> x *=2
    >>> x
    6
    #+END_SRC

** blocks

   A block is a group of statements that can be executed if a condition is true
   (conditional statements), or executed several times (loops), and so on. A
   block is created by indenting a part of your code; that is, putting spaces in
   front of it.

   *Note:* You can use tab characters to indent your blocks as well. Python interprets
   a tab as moving to the next tab stop, with one tab stop every eight spaces, but
   the standard and preferable style is to use spaces only, not tabs, and specifically
   four spaces per each level of indentation.

   In many languages, a special word or character (for example, begin or {) is used
   to start a block, and another (such as end or }) is used to end it. In Python, a
   colon (:) is used to indicate that a block is about to begin, and then every line
   in that block is indented (by the same amount). When you go back to the same amount
   of indentation as some enclosing block, you know that the current block has ended.

** conditions and conditional statements

*** boolean values

    The following values are considered by the interpreter to mean false when
    evaluated as a Boolean expression (for example, as the condition of an if
    statement):

    False    None    0    ""    ()    []    {}

*** conditional execution and the *if* statement

    There is a tiny difference compared with other languages, the
    *else if* in other language is *elif* in pyhon.

**** comparison operators

     |------------+--------------------------------------|
     | expression | description                          |
     |------------+--------------------------------------|
     | x == y     | x /equals/ y                         |
     |------------+--------------------------------------|
     | x < y      | x is /less than/ y                   |
     |------------+--------------------------------------|
     | x > y      | x is /greater than/ y                |
     |------------+--------------------------------------|
     | x >= y     | x is /greater than or equal to/ y    |
     |------------+--------------------------------------|
     | x <= y     | x is /less than or equal to/ y       |
     |------------+--------------------------------------|
     | x != y     | x is /not equal to/ y                |
     |------------+--------------------------------------|
     | x is y     | x and y are the same object          |
     |------------+--------------------------------------|
     | x is not y | x and y are different objects        |
     |------------+--------------------------------------|
     | x in y     | x is a member of the container y     |
     |------------+--------------------------------------|
     | x not in y | x is not a member of the container y |
     |------------+--------------------------------------|

     Comparisons can be /chained/ in Python, just like assignments -- you can put
     several comparison operators in a chain, like this: 0 < age < 100.

     *Tip:* When comparing things, you can also use the built-in function *cmp*.

     *is* tests for *identity*, rather than *equality*.

*** assertions

    There is a useful relative of the if statement, which works more or less like this
    (pseudocode):

    if not condition:
        crash program

    Basically, you can require that certain things be true (for example, when
    checking required properties of parameters to your functions or as an aid
    during initial testing and debugging). The keyword used in the statement
    is *assert*:

    #+BEGIN_SRC python
    >>> age = 10
    >>> assert 0 < age < 100
    >>> age = -1
    >>> assert 0 < age < 100
    Traceback (most recent call last):
      File "<stdin>", line 1, in ?
    AssertionError
    #+END_SRC

    It can be useful to put the assert statement in your program as a checkpoint, if you know
    something must be true for your program to work correctly.
    A string may be added after the condition, to explain the assertion:

    #+BEGIN_SRC python
    >>> age = -1
    >>> assert 0 < age < 100, 'The age must be realistic'
    Traceback (most recent call last):
      File "<stdin>", line 1, in ?
    AssertionError: The age must be realistic
    #+END_SRC

*** loops

**** *while* loop

     nothing unique compared with other languages.

**** *for* loop

     *in* is a useful expression:

     #+BEGIN_SRC python
     words = ['this', 'is', 'an', 'ex', 'parrot']
     for word in words:
     print word
     #+END_SRC

     Python has a built-in function to make ranges for you:
     #+BEGIN_SRC python
     >>> range(0, 10)
     [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
     >>> range(10)
     [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
     #+END_SRC

     The following program writes out the numbers from 1 to 100:

     #+BEGIN_SRC python
     for number in range(1, 101):
         print number
     #+END_SRC

**** iterating over dictionaries

     #+BEGIN_SRC python
     d = {'x': 1, 'y': 2, 'z': 3}
     for key in d:
         print key, 'corresponds to', d[key]
     #+END_SRC

**** iteration utilities

***** parallel iteration

      Sometimes you want to iterate over two sequences at the same time.
      Let’s say that you have the following two lists:

      #+BEGIN_SRC python
      names = ['anne', 'beth', 'george', 'damon']
      ages = [12, 45, 32, 102]
      #+END_SRC

      If you want to print out names with corresponding ages, you could do the following:

      #+BEGIN_SRC python
      for i in range(len(names)):
          print names[i], 'is', ages[i], 'years old'
      #+END_SRC

      Here, i serves as a standard variable name for loop indices (as these
      things are called).

      A useful tool for parallel iteration is the built-in function *zip*, which "zips"
      together the sequences, returning a list of tuples:

      #+BEGIN_SRC python
      >>> zip(names, ages)
      [('anne', 12), ('beth', 45), ('george', 32), ('damon', 102)]
      #+END_SRC

      Now I can unpack the tuples in my loop:

      #+BEGIN_SRC python
      for name, age in zip(names, ages):
          print name, 'is', age, 'years old'
      #+END_SRC

***** numbered iteration

      In some cases, you want to iterate over a sequence of objects and at the same
      time have access to the index of the current object.

      #+BEGIN_SRC python
      for string in strings:
          if 'xxx' in string:
              index = strings.index(string) # Search for the string in the list of strings
              strings[index] = '[censored]'
      #+END_SRC

      A better version would be the following:

      #+BEGIN_SRC python
      index = 0
      for string in strings:
          if 'xxx' in string:
              strings[index] = '[censored]'
              index += 1
      #+END_SRC

      This also seems a bit awkward, although acceptable. Another solution is to use
      the built-in function *enumerate*:

      #+BEGIN_SRC python
      for index, string in enumerate(strings):
          if 'xxx' in string:
              strings[index] = '[censored]'
      #+END_SRC

      This function lets you iterate over index-value pairs, where the indices are
      supplied automatically.

***** reversed and sorted iteration

      *reversed* and *sorted*, they're similar to the list methods *reverse* and *sort*,
      but they work on any sequence or iterable object, and instead of modifying the
      object in place, they return reversed and sorted versions:

      #+BEGIN_SRC python
      >>> sorted([4, 3, 6, 8, 3])
      [3, 3, 4, 6, 8]
      >>> sorted('Hello, world!')
      [' ', '!', ',', 'H', 'd', 'e', 'l', 'l', 'l', 'o', 'o', 'r', 'w']
      >>> list(reversed('Hello, world!'))
      ['!', 'd', 'l', 'r', 'o', 'w', ' ', ',', 'o', 'l', 'l', 'e', 'H']
      >>> ''.join(reversed('Hello, world!'))
      '!dlrow ,olleH'
      #+END_SRC

**** breaking out of loops

***** break

      To end (break out of) a loop, you use *break*.

***** continue

      The continue statement is used less often than break. It causes the
      current iteration to end, and to “jump” to the beginning of the next. It
      basically means “skip the rest of the loop body, but don’t end the loop.”

*** list comprehension

    List comprehension is a way of making lists from other lists. It works in a
    way similar to for loops and is actually quite simple:

    #+BEGIN_SRC python
    >>> [x*x for x in range(10)]
    [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
    #+END_SRC

    You can also add more for parts:

    #+BEGIN_SRC python
    >>> [(x, y) for x in range(3) for y in range(3)]
    [(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)]
    #+END_SRC

*** *pass*, *del*, and *exec*

**** pass

    Sometimes you need to do nothing. This may not be very often, but when it
    happens, it’s good to know that you have the pass statement:

    #+BEGIN_SRC python
    >>> pass
    >>>
    #+END_SRC

    Now, why on earth would you want a statement that does nothing? It can be
    useful as a placeholder while you are writing code. For example, you may
    have written an if statement and you want to try it, but you lack the code
    for one of your blocks. Consider the following:

    #+BEGIN_SRC python
    if name == 'Ralph Auldus Melish':
        print 'Welcome!'
    elif name == 'Enid':
        # Not finished yet...
    elif name == 'Bill Gates':
        print 'Access Denied'
    #+END_SRC

    This code won’t run because an empty block is illegal in Python. To fix this,
    simply add a pass statement to the middle block:

    #+BEGIN_SRC python
    if name == 'Ralph Auldus Melish':
        print 'Welcome!'
    elif name == 'Enid':
        # Not finished yet...
        pass
    elif name == 'Bill Gates':
        print 'Access Denied'
    #+END_SRC

**** del

     *del* just delete the /name/, itself(the value). In fact, there is no way to
     delete values in Python -- and you don't realyy need to, because the Python
     interpreter does it by itself whenever you don't use the value anymore.

**** exec and eval

***** exec

     The statement for executing a string is exec:

     #+BEGIN_SRC python
     >>> exec "print 'Hello, world!'"
     Hello, world!
     #+END_SRC

     In most cases, you want to supply it with a namespace—a place where it can put
     its variables. You want to do this so that the code doesn’t corrupt your namespace
     (that is, change your variables). For example, let’s say that the code uses
     the name sqrt:

     #+BEGIN_SRC python
     >>> from math import sqrt
     >>> exec "sqrt = 1"
     >>> sqrt(4)
     Traceback (most recent call last):
       File "<pyshell#18>", line 1, in ?
         sqrt(4)
     TypeError: object is not callable: 1
     #+END_SRC


     The exec statement is mainly useful when you build the code string on the fly.
     And if the string is built from parts that you get from other places, and possibly
     from the user, you can rarely be certain of exactly what it will contain. So to be
     safe, you give it a dictionary, which will work as a namespace for it.

     You do this by adding in <scope>, where <scope> is some dictionary that will function
     as the namespace for your code string:

     #+BEGIN_SRC python
     >>> from math import sqrt
     >>> scope = {}
     >>> exec 'sqrt = 1' in scope
     >>> sqrt(4)
     2.0
     >>> scope['sqrt']
     1
     #+END_SRC

***** eval

      A built-in function that is similar to exec is eval (for “evaluate”). Just
      as exec executes a series of Python statements, eval evaluates a Python
      expression (written in a string) and returns the resulting value. (exec
      doesn’t return anything because it is a statement itself.) For example, you
      can use the following to make a Python calculator:

      #+BEGIN_SRC python
      >>> eval(raw_input("Enter an arithmetic expression: "))
      Enter an arithmetic expression: 6 + 18 * 2
      42
      #+END_SRC

*** new function

    |--------------------------------------+--------------------------------------------------------------------------|
    | function                             | description                                                              |
    |--------------------------------------+--------------------------------------------------------------------------|
    | chr(n)                               | Returns a one-character string when passed ordinal n_ (0dn < 256)        |
    | eval(source[, globals[, locals]])    | Evaluates a string as an expression and returns                the value |
    |--------------------------------------+--------------------------------------------------------------------------|
    | enumerate(seq)                       | Yields (index, value) pairs suitable for iteration                       |
    |--------------------------------------+--------------------------------------------------------------------------|
    | ord(c)                               | Returns the integer ordinal value of a one-character string              |
    |--------------------------------------+--------------------------------------------------------------------------|
    | range([start,] stop[, step])         | Creates a list of integers                                               |
    |--------------------------------------+--------------------------------------------------------------------------|
    | reversed(seq)                        | Yields the values of seq in reverse order, suitable for iteration        |
    |--------------------------------------+--------------------------------------------------------------------------|
    | sorted(seq[, cmp][, key][, reverse]) | Returns a list with the values of seq in sorted order                    |
    |--------------------------------------+--------------------------------------------------------------------------|
    | xrange([start,] stop[, step])        | Creates an xrange object, used for iteration                             |
    |--------------------------------------+--------------------------------------------------------------------------|
    | zip(seq1,_seq2,...)                  | Creates a new sequence suitable for parallel iteration                   |
    |--------------------------------------+--------------------------------------------------------------------------|

* Abstraction

** creating functions

   Define a function with the *def* (or "function definition") statement:

   #+BEGIN_SRC python
   def hello(name):
       return 'Hello, ' + name + '!'
   #+END_SRC

** documenting functions

   If you want to document your functions so that you’re certain that others will
   understand them later on, you can add comments (beginning with the hash sign, #).

   Another way of writing comments is simple to write strings by themselves. Such
   strings can be particularly useful in some places, such as immediately after a
   *def* statement(and at the beginning of a module or a class). If you put a string
   at the beginning of a function, it is stored as part of the function and is called
   a /docstring/. The following code demonstrates how to add a docstring to a function:

   #+BEGIN_SRC python
   def square(x):
       'Calculates the square of the number x.'
       return x*x
   #+END_SRC

   The docstring may be accessed like this:

   #+BEGIN_SRC python
   >>> square.__doc__
   'Calculates the square of the number x.'
   #+END_SRC

   *Note:*__doc__ is a function attribute.

   A special built-in function called help can be quite useful. If you use it in the
   interactive interpreter, you can get information about a function, including its
   docstring:

   #+BEGIN_SRC python
   >>> help(square)
   Help on function square in module __main__:

   square(x)
   Calculates the square of the number x.
   #+END_SRC

** patameters

   *Note:* Parameters are kept in what is called a *local scope*.

   Strings (and numbers and tuples) are immutable, which means that you can’t modify
   them (that is, you can only replace them with new values).

   When two variables refer to the same list, they . . . refer to the same list. It’s
   really as simple as that. If you want to avoid this, you must make a copy of the list.
   When you do slicing on a sequence, the returned slice is always a copy. Thus, if
   you make a slice of the entire list, you get a copy:

   #+BEGIN_SRC python
   >>> names = ['Mrs. Entity', 'Mrs. Thing']
   >>> n = names[:]
   #+END_SRC

   In some languages (such as C++, Pascal, and Ada), rebinding parameters and having
   these changes affect variables outside the function is an everyday thing. In Python,
   it’s not directly possible; you can modify only the parameter objects themselves.


   The parameters that are supplied with a name like this are called keyword parameters.
   On their own, the key strength of keyword parameters is that they can help clarify
   the role of each parameter.

   #+BEGIN_SRC python
   >>> hello(greeting='Hello', name='world')
   Hello, world!
   #+END_SRC

   What really makes keyword arguments rock, however, is that you can give the parameters
   in the function default values:

   #+BEGIN_SRC python
   def hello(greeting='Hello', name='world'):
       print '%s, %s!' % (greeting, name)
   #+END_SRC

   When a parameter has a default value like this, you don’t need to supply it when
   you call the function! You can supply none, some, or all, as the situation might
   dictate:

   #+BEGIN_SRC python
   >>> hello()
   Hello, world!
   >>> hello('Greetings')
   Greetings, world!
   >>> hello('Greetings', 'universe')
   Greetings, universe!
   #+END_SRC

   As you can see, this works well with positional parameters, except that you must
   supply the greeting if you want to supply the name. What if you want to supply
   only the name, leaving the default value for the greeting?

   #+BEGIN_SRC python
   >>> hello(name='Gumby')
   Hello, Gumby!
   #+END_SRC

*** collecting parameters

    Sometimes it can be useful to allow the user to supply any number of parameters.
    For example, you can store only one name at a time. It would be nice to be able
    to store more names, like this:

    #+BEGIN_SRC python
    >>> store(data, name1, name2, name3)
    #+END_SRC

    For this to be useful, you should be allowed to supply as many names as you want.
    Actually, that’s quite possible.

    #+BEGIN_SRC python
    def print_params(*params):
        print params

    >>> print_params('Testing')
    ('Testing',)
    >>> print_params(1, 2, 3)
    (1, 2, 3)
    #+END_SRC

    The star in front of the parameter puts all the values into the same tuple.
    Does it handle keyword arguments (the same as parameters), too?

    #+BEGIN_SRC python
    >>> print_params_2('Hmm...', something=42)
    Traceback (most recent call last):
    File "<pyshell#60>", line 1, in ?
    print_params_2('Hmm...', something=42)
    TypeError: print_params_2() got an unexpected keyword argument 'something'
    #+END_SRC

    So we probably need another “gathering” operator for keyword arguments. What
    do you think that might be? Perhaps **?

    #+BEGIN_SRC python
    def print_params_3(**params):
        print params

    >>> print_params_3(x=1, y=2, z=3)
    {'z': 3, 'x': 1, 'y': 2}
    #+END_SRC

    Yep, we get a dictionary rather than a tuple. Let’s put them all together:

    #+BEGIN_SRC python
    def print_params_4(x, y, z=3, *pospar, **keypar):
        print x, y, z
        print pospar
        print keypar
    #+END_SRC
    This works just as expected:

    #+BEGIN_SRC python
    >>> print_params_4(1, 2, 3, 5, 6, 7, foo=1, bar=2)
    1 2 3
    (5, 6, 7)
    {'foo': 1, 'bar': 2}
    >>> print_params_4(1, 2)
    1 2 3
    ()
    {}
    #+END_SRC

*** reversing the process

    Let's say you have with two numbers that you want to add:

    #+BEGIN_SRC python
    def add(x ,y): return x + y
    params = (1, 2)
    #+END_SRC

    Instead of gathering the parameters, we want to /distribute/ them. This is
    simply done by using the * operator at the "other end" -- that is, when
    calling the function rather than when defining it:

    #+BEGIN_SRC python
    >>> add(*params)
    3
    #+END_SRC

    We can use the same technique with dictionaries, using the ** operator.
    Using * (or **) both when you define and call the function will simply pass
    the tuple or dictionary right through, so you might as well not have
    bothered:

    #+BEGIN_SRC python
    >>> def with_stars(**kwds):
            print kwds['name'], 'is', kwds['age'], 'years old'

    >>> def without_stars(kwds):
            print kwds['name'], 'is', kwds['age'], 'years old'
    >>> args = {'name': 'Mr. Me', 'age': 42}
    >>> with_stars(**args)
    Mr. Me is 42 years old
    >>> without_stars(args)
    Mr. Me is 42 years old
    #+END_SRC

    *Tip:* It may be useful to use these splicing operators to “pass through”
    parameters, without worrying too much about how many there are, and so forth.
    Here is an example:

    #+BEGIN_SRC python
    def foo(x, y, z, m=0, n=0):
        print x, y, z, m, n
    def call_foo(*args,**kwds):
        print "Calling foo!"
        foo(*args,**kwds)
    #+END_SRC

    This can be particularly useful when calling the constructor of a superclass.

** scoping

   There is a built-in function called *vars*, which returns the dictionary that
   contains variavles and its values.

   #+BEGIN_SRC python
   >>> x = 1
   >>> scope = vars()
   >>> scope['x']
   1
   >>> scope['x'] += 1
   >>> x
   2
   #+END_SRC

   *Caution:* In general, you should not modify the dictionary returned by vars
   because, according to the official Python documentation, the result is
   undefined. In other words, you might not get the result you’re after.

   This sort of “invisible dictionary” is called a /namespace or scope./

   #+BEGIN_SRC python
   >>> def foo(): x = 42
   >>> x = 1
   >>> foo()
   >>> x
   1
   #+END_SRC

   Here foo changes (rebinds) the variable x, but when you look at it in the
   end, it hasn’t changed after all. That’s because when you call foo, a *new*
   namespace is created, which is used for the block inside foo. The assignment
   x = 42 is performed in this inner scope (the *local namespace*), and therefore
   it doesn’t affect the x in the outer (*global*) scope.

   *THE PROBLEM OF SHADOWING*
   Reading the value of global variables is not a problem in general, but one
   thing may make it problematic. If a local variable or parameter exists with
   the same name as the global variable you want to access, you can’t do it
   directly. The global variable is shadowed by the local one. If needed, you
   can still gain access to the global variable by using the function globals,
   a close relative of vars, which returns a dictionary with the global variables.
   (locals returns a dictionary with the local variables.)
   For example, if you had a global variable called parameter in the previous
   example, you couldn’t access it from within combine because you have a parameter
   with the same name. In a pinch, however, you could have referred to it as
   globals()['parameter']:

   #+BEGIN_SRC python
   >>> def combine(parameter):
       print parameter + globals()['parameter']
   >>> parameter = 'berry'
   >>> combine('Shrub')
   Shrubberry
   #+END_SRC


   *Rebinding* global variables (making them refer to some new value) is another
   matter. If you assign a value to a variable inside a function, it automatically
   becomes local unless you tell Python otherwise.

   #+BEGIN_SRC python
   >>> x = 1
   >>> def change_global():
           global x
           x += 1
   >>> chagne_global()
   >>> x
   2
   #+END_SRC

   Python functions may be nested.

   #+BEGIN_SRC python
   def foo():
       def bar():
           print "Hello, world"
       bar()
   #+END_SRC

   Nesting is normally not all that useful, but there is one particular application
   that stands out: using one function to “create” another. This means that you can
   (among other things) write functions like the following:

   #+BEGIN_SRC python
   def multiplier(factor):
       def multiplyByFactor(number):
           return number*factor
       return multiplyByFactor
   #+END_SRC

   One function is inside another, and the outer function returns the inner one;
   that is, the function itself is returned—it is not called. What’s important is
   that the returned function still has access to the scope where it was defined;
   in other words, it carries its environment (and the associated local variables)
   with it!
   Each time the outer function is called, the inner one gets redefined, and each
   time, the variable factor may have a new value. Because of Python’s nested scopes,
   this variable from the outer local scope (of multiplier) is accessible in the
   inner function later on:

   #+BEGIN_SRC python
   >>> double = multiplier(2)
   >>> double(5)
   10
   >>> triple = multiplier(3)
   >>> triple(3)
   9
   >>> multiplier(5)(4)
   20
   #+END_SRC

   A function such as multiplyByFactor that stores its enclosing scopes is called a
   closure.
   Normally, you cannot rebind variables in outer scopes. In Python 3.0, however,
   the keyword nonlocal is introduced. It is used in much the same way as global,
   and lets you assign to variables in outer (but non-global) scopes.

** recursion

   A similar function definition would be

   #+BEGIN_SRC python
   def recursion():
       return recursion()
   #+END_SRC

   A useful recursive function usually consists of the following parts:

   * A base case (for the smallest possible problem) when the function returns a value
   directly
   * A recursive case, which contains one or more recursive calls on smaller parts of the
   problem

** new function

    |-------------------------------+-----------------------------------------------------------------|
    | map(func, seq [, seq, ...])   | Applies the function to all the elements in the sequences       |
    |-------------------------------+-----------------------------------------------------------------|
    | filter(func, seq)             | Returns a list of those elements for which the function is true |
    |-------------------------------+-----------------------------------------------------------------|
    | reduce(func, seq [, initial]) | Equivalent to func(func(func(seq[0], seq[1]), seq[2]), ...)     |
    |-------------------------------+-----------------------------------------------------------------|
    | sum(seq)                      | Returns the sum of all the elements of seq                      |
    |-------------------------------+-----------------------------------------------------------------|
    | apply(func[, args[, kwargs]]) | Calls the function, optionally supplying argument               |
    |-------------------------------+-----------------------------------------------------------------|

* More Abstraction

** The Magic of Objects

   Some of the most important benefits of objects include the following:

   • *Polymorphism*: You can use the same operations on objects of different classes, and
   they will work as if “by magic.”

   • *Encapsulation*: You hide unimportant details of how objects work from the outside
   world.

   • *Inheritance*: You can create specialized classes of objects from general ones.

** polymorphism and methods

   The term /polymorphism/ is derived from a Greek word meaning "having mutliple forms."
   Basically, that means that even if you don't konw what kind of bject a variable refers
   to, you may still be able to perform operations on it that will work differently depending
   on teh type (or class) of the object.

*** polymorphism comes in many forms

    Plymorphism is at work every time you can "do something" to an object without having
    to know exactly what kind of object it is.

** encapsulation

    /Encapsulation/ is the principle of hiding unnecessary details from the rest of the
    world. This may sound like polymorphism -- there, too, you use an object without
    knowing its inner details. The two concepts are similar because they are both
    /principles of abstraction/.
    But encapsulation isn't the same as polymorphism. Polymorphism enables you to call
    the methods of an object without konwing its class(type of object). Encapsulation
    enables you to use the object without worrying about how it's constructed.

** inheritance

    Inheritance is another way of dealing with laziness (in the positive sense).
    Porgrammers want to avoid typing the same code more than once. We avoided that
    earlier by making functions.

** classes and types

   *Note:* In everyday speech, we denote classes of objects with plural nouns such
   as “birds” and “larks.” In Python, it is customary to use singular, capitalized
   nouns such as Bird and Lark .

*** making classes

    Here is an example:

    #+BEGIN_SRC python
    __metclass__ = type # Make sure we get new style classes
    class Person:

        def setName(self, name):
            self.name = name

        def getName(self):
            return self.name

        def greet(self):
            print "Hello, world! I am %s." % self.name
    #+END_SRC

   *Note：* There is a difference between so-called old-style and new-style classes.
   There is really no reason to use the old-style classes anymore, except that they’re
   what you get by default in Python versions prior to 3.0. To get new-style classes,
   you should place the assignment __metaclass__ = type at the beginning of your script
   or module. (I may not explicitly include this statement in every example.) There are
   also other solutions, such as subclassing a new-style class (for example, object ).
   You learn more about subclassing in a minute. In Python 3.0, there is no need to worry
   about this, as old-style classes don’t exist there.

   #+BEGIN_SRC python
   >>> foo = Person()
   >>> bar = Person()
   >>> foo.setName('Luke Skywalker')
   >>> bar.setName('Anakin Skywalker')
   >>> foo.greet()
   Hello, world! I am Luke Skywalker.
   >>> bar.greet()
   Hello, world! I am Anakin Skywalker.
   #+END_SRC

   The *self* is always the object itself. Without it, none of the methods would have
   access to the object itself -- the object whose attributes they are supposed to
   manipulate. As before, the attributes are also accessible from the outside:

   #+BEGIN_SRC python
   >>> foo.name
   'Luke Skywlader'
   >>> bar.name = 'Yoda'
   >>> bar.greet()
   Hello, world! I am Yoda.
   #+END_SRC

   *Tip:* Another way of viewing this is that foo.greet() is simply a convenient way of
   writing *Person.greet(foo)* , if you know that foo is an instance of *Person*.

**** attributes, functions, and methods

     The *self* parameter is, in fact, what distinguishes methods from the functions.
     Methods(or, more technically, /bound methods/) have their first parameter
     bound to the instance they belong to, so you don't have to supply it.
     While you can certainly bind an attribute to a plain function, it won’t have that
     special *self* parameter:

     #+BEGIN_SRC python
     >>> class Class:
         def method(self):
             print 'I have a self!'

     >>> def function():
             print "I don't..."

     >>> instance = Class()
     >>> instance.method()
     I have a self!
     >>> instance.method = function
     >>> instance.method()
     I don't...
     #+END_SRC

     You’re free to use another variable that refers to the same method:

     #+BEGIN_SRC python
     >>> class Bird:
         song = 'Squaawk!'
         def sing(self):
             print self.song
     >>> bird = Bird()
     >>> bird.sing()
     Squaawk!
     >>> birdsong = bird.sing
     >>> birdsong()
     Squaawk!
     #+END_SRC

**** privacy revisited

     By default, you can access the attributes of an object from the "outside".
     To make a method or attribute private (inaccessible from the outside), simply
     start its name with two underscores:

     #+BEGIN_SRC python

     class Secretive:
         def __inaccessible(self):
             print "Bet you can't see me..."
         def accessible(self):
             print "The secret messge is:"
             self.__inaccessible()

     #+END_SRC

     Now __inaccessible is inaccessible to the outside world, while it can still be
     used inside the class.

     #+BEGIN_SRC python
     >>> s = Secretive()
     >>> s.__inaccessible()
     Traceback (most recent call last):
       File "<pyshell#112>", line 1, in ?
         s.__inaccessible()
     AttributeError: Secretive instance has no attribute '__inaccessible'
     >>> s.accessible()
     The secret message is:
     Bet you can't see me...
     #+END_SRC

     Although the double underscores are a bit strange, this seems like a standard
     private method, as found in other languages. What’s not so standard is what
     actually happens. Inside a class definition, all names beginning with a double
     underscore are “translated” by adding a single underscore and the class name
     to the beginning:

     #+BEGIN_SRC python
     >>> Secretive._Secretive__inaccessible
     <unbound method Secretive.__inaccessible>
     #+END_SRC

     If you know how this works behind the scenes, it is still possible to access private
     methods outside the class, even though you’re not supposed to:

     #+BEGIN_SRC python
     >>> s._Secretive__inaccessible()
     Bet you can't see me...
     #+END_SRC

     So, in short, you can’t be sure that others won’t access the methods and attributes
     of your objects, but this sort of name-mangling is a pretty strong signal that they
     shouldn’t.If you don’t want the name-mangling effect, but you still want to send a
     signal for other objects to stay away, you can use a single initial underscore.
     This is mostly just a convention, but has some practical effects. For example,
     names with an initial underscore aren’t imported with starred imports
     (from module import *).

*** the class namespace

    All the code in the class statement is executed in a special namespace—the
    class namespace. This namespace is accessible later by all members of the class.

*** specifying a superclass

    You indicate the superclass in a class statement by writing it in parentheses after
    the class name:

    #+BEGIN_SRC python
    class Filter:
        def init(self):
            self.blocked = []
        def filter(self, sequence):
            return [x for x in sequence if x not in self.blocked]

    class SPAMFilter(Filter): # SPAMFilter is a subclass of Filter
        def init(self): # Overrides init method from Filter superclass
            self.blocked = ['SPAM']
    #+END_SRC

**** investigating inheritance

     If you want to find out whether a class is a subclass of another, you can use
     the built-in method *issubclass:*

     #+BEGIN_SRC python
     >>> issubclass(SPAMFilter, Filter)
     True
     >>> issubclass(Filter, SPAMFilter)
     False
     #+END_SRC

     If you have a class and want to know its base classed, you can access its special
     attribute *__bases__*:

     #+BEGIN_SRC python
     >>> SPAMFilter.__bases__
     (<class __main__.Filter at 0x171e40>,)
     >>> Filter.__bases__
     ()
     #+END_SRC

     In a similar manner, you can check whether an object is an instance of a class by
     using isinstance:

     #+BEGIN_SRC python
     >>> s = SPAMFilter()
     >>> isinstance(s, SPAMFilter)
     True
     >>> isinstance(s, Filter)
     True
     >>> isinstance(s, str)
     False
     #+END_SRC

     *Note* Using *isinstance* is usually not good practice. Relying on polymorphism is
     almost always better.

**** multiple superclass

     #+BEGIN_SRC python
     class Calculator:
         def calculate(self, expression):
             self.value = eval(expression)
     class Talker:
         def talk(self):
             print 'Hi, my value is', self.value
     class TalkingCalculator(Calculator, Talker):
         pass
     #+END_SRC

     If you are using multiple inheritance, there is one thing you should look out for:
     if a method is implemented differently by two or more of the superclasses (that is,
     you have two different methods with the same name), you must be careful about the
     order of these superclasses (in the class statement). The methods in the earlier
     classes override the methods in the later ones.

**** interfaces and introspection

     The “interface” concept is related to polymorphism. When you handle a polymorphic
     object, you only care about its interface (or “protocol”)—the methods and attributes
     known to the world.
     In Python, you don’t explicitly specify which methods an object needs to have to be
     acceptable as a parameter. For example, you don’t write interfaces explicitly (as
     you do in Java); you just assume that an object can do what you ask it to do. If it
     can’t, the program will fail.

     Usually, you simply require that objects conform to a certain interface (in other
     words,implement certain methods), but if you want to, you can be quite flexible in
     your demands.Instead of just calling the methods and hoping for the best, you can
     check whether the required methods are present, and if not, perhaps do something else:

     #+BEGIN_SRC python
     >>> hasattr(tc, 'talk')
     True
     >>> hasattr(tc, 'fnord')
     False
     #+END_SRC

     In the preceding code, you find that tc (a TalkingCalculator, as described
     earlier in this chapter) has the attribute talk (which refers to a method),
     but not the attribute fnord. If you wanted to, you could even check whether
     the talk attribute was callable:

     #+BEGIN_SRC python
     >>> callable(getattr(tc, 'talk', None))
     True
     >>> callable(getattr(tc, 'fnord', None))
     False
     #+END_SRC

     *Note:* The function callable is no longer available in Python 3.0. Instead of
     callable(x) , you can use *hasattr(x, '__call__')*.

** thoughts on OOD

   • Gather what belongs together. If a function manipulates a global variable, the two of
   them might be better off in a class, as an attribute and a method.

   • Don’t let objects become too intimate. Methods should mainly be concerned with the
   attributes of their own instance. Let other instances manage their own state.

   • Go easy on the inheritance, especially multiple inheritance. Inheritance is useful at
   times, but can make things unnecessarily complex in some cases. And multiple inherit-
   ance can be very difficult to get right and even harder to debug.

   • Keep it simple. Keep your methods small. As a rule of thumb, it should be possible to
   read (and understand) most of your methods in, say, 30 seconds. For the rest, try to keep
   them shorter than one page or screen.

   When determining which classes you need and which methods they should have, you may
   try something like this:

   1. Write down a description of your problem (what should the program do?). Underline all
   the nouns, verbs, and adjectives.

   1. Go through the nouns, looking for potential classes.

   2. Go through the verbs, looking for potential methods.

   3. Go through the adjectives, looking for potential attributes.

   4. Allocate methods and attributes to your classes.

** new function
   |----------------------------------+-----------------------------------------------------------------------|
   | function                         | description                                                           |
   |----------------------------------+-----------------------------------------------------------------------|
   | callable(object)                 | Determines if the object is callable (such as a function or a method) |
   |----------------------------------+-----------------------------------------------------------------------|
   | getattr(object, name[, default]) | Gets the value of an attribute, optionally providing a default        |
   |----------------------------------+-----------------------------------------------------------------------|
   | hasattr(object, name)            | Determines if the object has the given attribute                      |
   |----------------------------------+-----------------------------------------------------------------------|
   | isinstance(object, class)        | Determines if the object is an instance of the class                  |
   |----------------------------------+-----------------------------------------------------------------------|
   | issubclass(A, B)                 | Determines if A is a subclass of B                                    |
   |----------------------------------+-----------------------------------------------------------------------|
   | random.choice(sequence)          | Chooses a random element from a nonempty sequence                     |
   |----------------------------------+-----------------------------------------------------------------------|
   | setattr(object, name, value)     | Sets the given attribute of the object to value                       |
   |----------------------------------+-----------------------------------------------------------------------|
   | type(object)                     | Returns the type of the object                                        |
   |----------------------------------+-----------------------------------------------------------------------|

* Exceptions

** raise exceptions

*** the raise statement

    To raise an exception, you use the *raise* statement with an argument that
    is either a class(which should subclass *Excption*) or an instance, When
    using a class, an instance is created automatically Here is an example,
    using the built-in exception class *Exception*:

   #+BEGIN_SRC python
   >>> raise Exception
   Traceback (most recent call last):
     File "<stdin>", line 1, in ?
   Exception
   >>> raise Exception('hyperdrive overload')
   Traceback (most recent call last):
     File "<stdin>", line 1, in ?
   Exception: hyperdrive overload
   #+END_SRC

    Many built-in classes are available. You can find a description of all of
    them in the Python Library Reference, you can also explore them yourself
    with the interactive interpreter. To list the contents of a mudule, you
    can use the *dir* function:

    #+BEGIN_SRC python
    >>> import exceptions
    >>> dir(exceptions)
    ['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException',
    'BufferError', 'BytesWarning', 'DeprecationWarning', 'EOFError',
    'EnvironmentError', 'Exception', 'FloatingPointError', 'FutureWarning'...]
     #+END_SRC

    All of these exception classes can be used in your *raise* statements:

    #+BEGIN_SRC python
    >>> raise ArithmeticError
    Traceback (most recent call last):
      File "<stdin>", line 1, in ?
    ArithmeticError
    #+END_SRC

*** custom exception classes

    Just like any other class—but be sure to subclass Exception (either directly
    or indirectly, which means that subclassing any other built-in exception is
    okay).

    #+BEGIN_SRC python
    class SomeCustomException(Exception): pass
    #+END_SRC

** catching exceptions

   You do this with the *try/except* statement.

   #+BEGIN_SRC python
   try:
       x = input('Enter the first number: ')
       y = input('Enter the second number: ')
       print x / y
   except ZeroDivisionError:
       print "The second number can't be zero!"
   #+END_SRC

*** look, ma, no arguments!

    If you have caught an exception but you want to raise it again (pass it on,
    so to speak), you can call raise without any arguments.

    As an example of how this might be useful, consider a calculator class that
    has the capability to “muffle” ZeroDivisionError exceptions. If this behavior
    is turned on, the calculator prints out an error message instead of letting
    the exception propagate. This is useful if the calculator is used in an
    interactive session with a user, but if it is used internally in a program,
    raising an exception would be better. Therefore, the muffling can be turned
    off. Here is the code for such a class:

    #+BEGIN_SRC python
    class MuffledCalculator:
        muffled = False
        def calc(self, expr):
            try:
                return eval(expr)
            except ZeroDivisionError:
                if self.muffled:
                    print 'Division by zero is illegal'
                else:
                    raise
    #+END_SRC

    *Note:* If division by zero occurs and muffling is turned on, the calc method
    will (implicitly) return None . In other words, if you turn on muffling, you
    should not rely on the return value.

*** more than one except clause

    You can simply add another *except* clause to the same *try/except* statement:

    #+BEGIN_SRC python
    try:
        x = input('Enter the first number: ')
        y = input('Enter the second number: ')
        print x/y
    except ZeroDivisionError:
        print "The second number can't be zero!"
    except TypeError:
        print "That wasn't a number, was it?"
    #+END_SRC

*** catching two exceptions with one block

    If you want to catch more than one exception type with one block, you can
    specify them all in a tuple, as follows:

    #+BEGIN_SRC python
    try:
        x = input('Enter the first number: ')
        y = input('Enter the second number: ')
        print x/y
    except (ZeroDivisionError, TypeError, NameError):
        print 'Your numbers were bogus...'
    #+END_SRC

*** catching the object

    If you want access to the exception object itself in an *except* clause, you
    can use two arguments instead of one. This can be useful if you want your
    program to keep running, but you want to log the error somehow. The following
    is a sample program that prints out the exception (if it occurs), but keeps
    running:

    #+BEGIN_SRC python
    try:
        x = input('Enter the first number: ')
        y = input('Enter the second number: ')
        print x/y
    except (ZeroDivisionError, TypeError), e:
        print e
    #+END_SRC

    *Note:* In Python 3.0, the except clause will be written
    *except (ZeroDivisionError, TypeError) as e*.

*** a real catchall

    If you do want to catch all exceptions in a piece of code, you can simply
    omit the exception class from the except clause:


    #+BEGIN_SRC python
    try:
        x = input('Enter the first number: ')
        y = input('Enter the second number: ')
        print x/y
    except:
        print 'Something wrong happened...'
    #+END_SRC


    *Caution:* Catching all exceptions like this is risky business because it
    will hide errors you haven’t thought of as well as those you’re prepared
    for. It will also trap attempts by the user to terminate execution by Ctrl-C,
    attempts by functions you call to terminate by sys.exit , and so on. In most
    cases, it would be better to use *except Exception, e* and perhaps do some
    checking on the exception object, e .

*** and finally...

    Finally, there is the *finally* clause. You use it to do housekeeping after
    a possible exception. It is combined with a try clause:

    #+BEGIN_SRC python
    x = None
    try:
        x = 1 / 0
    finally:
        print 'Cleaning up...'
        del x
    #+END_SRC

    you are guaranteed that the finally clause will be executed, no matter what
    exceptions occur in the try clause.

** exceptions and funcions

   Exceptions and functions work together quite naturally. If an exception is
   raised inside a function, and isn’t handled there, it propagates (bubbles
   up) to the place where the function was called. If it isn’t handled there
   either, it continues propagating until it reaches the main program (the
   global scope), and if there is no exception handler there, the program
   halts with a stack trace.

** the zen of exceptions

   Exception handling isn’t very complicated. If you know that some part of
   your code may cause a certain kind of exception, and you don’t simply want
   your program to terminate with a stack trace if and when that happens, then
   you add the necessary try/except or try/finally statements (or some
   combination thereof) to deal with it, as needed.

   Sometimes, you can accomplish the same thing with conditional statements
   as you can with exception handling, but the conditional statements will
   probably end up being less natural and less readable. On the other hand,
   some things that might seem like natural applications of if/else may in
   fact be implemented much better with try/except.

** new function

   |-------------------------------------+-----------------------------|
   | function                            | description                 |
   |-------------------------------------+-----------------------------|
   | warning.filterwarnings(action, ...) | used to filter out warnings |
   |-------------------------------------+-----------------------------|

* Magic Methods, Properties, and Iterators

  Before Python 3.0, to make your classes “new-style,” you should either put
  the assignment *__metaclass__* = type at the top of your modules or (directly
  or indirectly) subclass the built-in class (or, actually, type) object (or
  some other new-style class).

  #+BEGIN_SRC python
  class NewStyle(object):
      more_code_here
  #+END_SRC

** constructors

   What separates constructors from ordinary methods, however, is that the
   constructors are called automatically right after an object has been created.

   Creating constructors in Python is really easy; simply change the init
   method’s name from the plain old init to the magic version, *__init__*:

   #+BEGIN_SRC python
   class FooBar:
       def __init__(self):
           self.somevar = 42

   >>> f = FooBar()
   >>> f.somevar
   42
   #+END_SRC

   But you may wonder what happens if you give the constructor some parameters
   to work with. Consider the following:

   #+BEGIN_SRC python
   class FooBar:
       def __init__(self, value=42):
           self.somvar = value

   >>> f = FooBar('This is a constructor argument')
   >>> f.somevar
   'This is a constructor argument'
   #+END_SRC

   *Note:* Python has a magic method called *__del__* , also known as the
   destructor. It is called just before the object is destroyed (garbage-collected).

** overriding methods in general, and the constructor in particular

   Overriding is an important aspect of the inheritance mechanism in general, and
   may be especially important for constructors. Constructors are there to
   initialize the state of the newly constructed object, and most subclasses will
   need to have initialization code of their own, in addition to that of the
   superclass. Even though the mechanism for overriding is the same for all methods,
   you will most likely encounter one particular problem more often when dealing
   with constructors than when overriding ordinary methods: if you override the
   constructor of a class, you need to call the constructor of the superclass
   (the class you inherit from) or risk having an object that isn’t properly
   initialized.
   Consider the following class, Bird:

   #+BEGIN_SRC python
   class Bird:
       def __init__(self):
           self.hungry = True
       def eat(self):
           if self.hungry:
           print 'Aaaah...'
           self.hungry = False
       else:
           print 'No, thanks!'

   >>> b = Bird()
   >>> b.eat()
   Aaaah...
   >>> b.eat()
   No, thanks!
   #+END_SRC

   As you can see from this example, once the bird has eaten, it is no longer
   hungry. Now consider the subclass SongBird, which adds singing to the
   repertoire of behaviors:

   #+BEGIN_SRC python
   class SongBird(Bird):
       def __init__(self):
           self.sound = 'Squawk!'
       def sing(self):
           print self.sound

   >>> sb = SongBird()
   >>> sb.sing()
   Squawk!
   #+END_SRC

   Because SongBird is a subclass of Bird, it inherits the eat method, but if
   you try to call it, you’ll discover a problem:

   #+BEGIN_SRC python
   >>> sb.eat()
   Traceback (most recent call last):
     File "<stdin>", line 1, in ?
     File "birds.py", line 6, in eat
       if self.hungry:
   AttributeError: SongBird instance has no attribute 'hungry'
   #+END_SRC

   The exception is quite clear about what’s wrong: the SongBird has no attribute
   called hungry. Why should it? In SongBird, the constructor is overridden, and
   the new constructor doesn’t contain any initialization code dealing with the
   hungry attribute. To rectify the situation, the SongBird constructor must call
   the constructor of its superclass, Bird, to make sure that the basic
   initialization takes place. There are basically two ways of doing this: by
   calling the unbound version of the superclass’s constructor or by using the
   super function.

*** calling the unbound superclass constructor

    The approach described in this section is, perhaps, mainly of historical
    interest. With current versions of Python, using the super function
    (as explained in the following section) is clearly the way to go
    (and with Python 3.0, it will be even more so).

    #+BEGIN_SRC python
    class SongBird(Bird):
        def __init__(self):
            Bird.__init__(self)
            self.sound = 'Squawk!'
        def sing(self):
            print self.sound
    #+END_SRC

*** using the *super* function

    It is called with the current class and instance as its arguments, and any
    method you call on the returned object will be fetched from the superclass
    rather than the current class. So, instead of using Bird in the SongBird
    constructor, you can use super(SongBird, self). Also, the __init__ method
    can be called in a normal (bound) fashion.

    #+BEGIN_SRC python
    __metaclass__ = type # super only works with new-style classes

    class Bird:
        def __init__(self):
            self.hungry = True
        def eat(self):
            if self.hungry:
                print 'Aaaah...'
                self.hungry = False
            else:
                print 'No, thanks!'

    class SongBird(Bird):
        def __init__(self):
            super(SongBird, self).__init__()
            self.sound = 'Squawk!'
        def sing(self):
            print self.sound
    #+END_SRC

** item access

   One useful set of magic methods described in this section allows you to create
   objects that behave like sequences or mappings. The basic sequence and mapping
   protocol is pretty simple. However, to implement all the functionality of
   sequences and mappings, there are many magic methods to implement.

   *Note:* The word protocol is often used in Python to describe the rules governing
   some form of behavior. This is somewhat similar to the notion of interfaces.

   The protocol says something about which methods you should implement and what
   those methods should do. Because polymorphism in Python is based on only the
   object’s behavior (and not on its ancestry, for example, its class or superclass,
   and so forth), this is an important concept: where other languages might require
   an object to belong to a certain class or to implement a certain interface,
   Python often simply requires it to follow some given protocol. So, to be a
   sequence, all you have to do is follow the sequence protocol.

*** the basic sequence and mapping protocol

    Sequences and mappings are basically collections of items. To implement their
    basic behavior (protocol), you need two magic methods if your objects are
    immutable, or four if they are mutable:

    *__len__(self):*
    This method should return the number of items contained in the collection. For
    a sequence, this would simply be the number of elements. For a mapping, it
    would be the number of key-value pairs. If __len__ returns zero (and you don’t
    implement __nonzero__, which overrides this behavior), the object is treated
    as false in a Boolean context (as with empty lists, tuples, strings, and
    dictionaries).

    *__getitem__(self, key):*
    This should return the value corresponding to the given key. For a sequence,
    the key should be an integer from zero to n–1 (or, it could be negative,
    as noted later), where n is the length of the sequence. For a mapping, you
    could really have any kind of keys.

    *__setitem__(self, key, value):*
    This should store value in a manner associated with key, so it can later be
    retrieved with __getitem__. Of course, you define this method only for
    mutable objects.

    *__delitem__(self, key):*
    This is called when someone uses the del statement on a part of the object,
    and should delete the element associated with key. Again, only mutable objects
    (and not all of them—only those for which you want to let items be removed)
    should define this method.

    Some extra requirements are imposed on these methods:
    • For a sequence, if the key is a negative integer, it should be used to count
    from the end. In other words, treat x[-n] the same as x[len(x)-n].
    • If the key is of an inappropriate type (such as a string key used on a
    sequence), a TypeError may be raised.
    • If the index of a sequence is of the right type, but outside the allowed
    range, an IndexError should be raised.

** properties

   Accessors are simply methods with names such as getHeight and setHeight, and
   are used to retrieve or rebind some attribute (which may be private to the class).
   Encapsulating state variables (attributes) like this can be important if
   certain actions must be taken when accessing the given attribute. For example,
   consider the following Rectangle class:

   #+BEGIN_SRC python
   class Rectangle:
       def __init__(self):
           self.width = 0
           self.height = 0
       def setSize(self, size):
           self.width, self.height = size
       def getSize(self):
           return self.width, self.height

   >>> r = Rectangle()
   >>> r.width = 10
   >>> r.height = 5
   >>> r.getSize()
   (10, 5)
   >>> r.setSize((150, 100))
   >>> r.width
   150
   #+END_SRC

   If you have lots of attributes, should you wrap all in accessors? That is a
   possibility, of course. However, it would be impractical(and kind of silly),
   luckily, Python can hide your accessors for you, making all of your attributes
   look alike. Those attribute that are defined through their accessors are often
   called /properites/.

*** the property function

    #+BEGIN_SRC python
    __metclass__ = type

    class Rectangle:
        def __init__(self):
            self.width = 0
            self.height = 0
        def setSize(self, size):
            self.width, self.height = size
        def getSize(self):
            return self.width, self,height
        size = property(getSize, setSize)
    #+END_SRC

    In this new version of Rectangle, a property is created with the property
    function with the accessor functions as arguments (the getter first, then
    the setter), and the name size is then bound to this property. After this,
    you no longer need to worry about how things are implemented, but can treat
    width, height, and size the same way:

    #+BEGIN_SRC python
    >>> r = Rectange()
    >>> r.width = 10
    >>> r.height = 5
    >>> r.size
    (10, 5)
    >>> r.size = 150, 100
    >>> r.width
    150
    #+END_SRC

    In fact, the property function may be called with zero, one, three, or four
    arguments as well. If called without any arguments, the resulting property
    is neither readable nor writable.If called with only one argument (a getter
    method), the property is readable only. The third (optional) argument is a
    method used to delete the attribute (it takes no arguments). The fourth
    (optional) argument is a docstring. The parameters are called fget, fset,
    fdel, and doc—you can use them as keyword arguments if you want a property
    that, say, is only writable and has a docstring.

** static methods and class methods

   Static methods and class methods are created by wrapping methods in objects
   of the *staticmethod* and *classmethod* types, respectively. Static methods
   are defined without self arguments, and they can be called directly on the
   class itself. Class methods are defined with a self-like parameter normally
   called *cls*. You can call class methods directly on the class object too,
   but the cls parameter then automatically is bound to the class.

   #+BEGIN_SRC python
   __metclass__ = type

   class MyClass:
       def smeth():
           print 'This is a static method'
       smeth = staticmethod(smeth)

       def cmeth(cls):
           print 'This is a class method of', cls
       cmeth = classmethod(cmeth)
   #+END_SRC

   The technique of wrapping and replacing the methods manually like this is a
   bit tedious. In Python 2.4, a new syntax was introduced for wrapping methods
   like this, called /decorators/. (They actually work with any callable objects
   as wrappers, and can be used on both methods and functions.) You specify one
   or more decorators (which are applied in reverse order) by listing them above
   the method (or function), using the @ operator:

   #+BEGIN_SRC python
   __metaclass__ = type

   class MyClass:
       @staticmethod
       def smeth():
           print 'This is a static method'

       @classmethod
       def cmeth(cls):
           print 'This is a class method of', cls
   #+END_SRC

   Once you’ve defined these methods, they can be used like this (that is, without
   instantiating the class):

   #+BEGIN_SRC python
   >>> MyClass.smeth()
   This is a static method
   >>> MyClass.cmeth()
   This is a class method of <class '__main__.MyClass'>
   #+END_SRC

** __getattr__, __setattr__, and friends

   It’s possible to intercept every attribute access on an object. Among other
   things, you could use this to implement properties with old-style classes
   (where property won’t necessarily work as it should). To have code executed
   when an attribute is accessed, you must use a couple of magic methods. The
   following four provide all the functionality you need (in old-style classes,
   you only use the last three):

   + *__getattribute__(self, name)*: Automatically called when the attribute name
   is accessed. (This works correctly on new-style classes only.)

   + *__getattr__(self, name)*: Automatically called when the attribute name is
   accessed and the object has no such attribute.

   + *__setattr__(self, name, value)*: Automatically called when an attempt is
   made to bind the attribute name to value.

   + *__delattr__(self, name)*: Automatically called when an attempt is made to
   delete the attribute name.

   Although a bit trickier to use (and in some ways less efficient) than property,
   these magic methods are quite powerful, because you can write code in one of
   these methods that deals with several properties. (If you have a choice,
   though, stick with property.) Here is the Rectangle example again, this time
   with magic methods:

   #+BEGIN_SRC python
   class Rectangle:
       def __init__(self):
           self.width = 0
           self.height = 0
       def __setattr__(self, name, value):
           if name == 'size':
               self.width, self.height = value
           else:
               self.__dict__[name] = value
       def __getattr__(self, name):
           if name == 'size':
               return self.width, self.height
           else:
               raise AttributeError
   #+END_SRC

   As you can see, this version of the class needs to take care of additional
   administrative details. When considering this code example, it’s important
   to note the following:

   + The *__setattr__* method is called even if the attribute in question is not
   size. Therefore, the method must take both cases into consideration: if the
   attribute is size, the same operation is performed as before; otherwise, the
   magic attribute __dict__ is used. It contains a dictionary with all the
   instance attributes. It is used instead of ordinary attribute assignment to
   avoid having __setattr__ called again (which would cause the program to
   loop endlessly).

   + The *__getattr__* method is called only if a normal attribute is not found,
   which means that if the given name is not size, the attribute does not exist,
   and the method raises an AttributeError. This is important if you want the
   class to work correctly with built-in functions such as hasattr and getattr.
   If the name is size, the expression found in the previous implementation is
   used.

** Iterators

*** the iterator protocol

    To iterate means to repeat something several times—what you do with loops.
    Until now I have iterated over only sequences and dictionaries in for loops,
    but the truth is that you can iterate over other objects, too: objects that
    implement the *__iter__* method.

    The __iter__ method returns an iterator, which is any object with a method
    called next, which is callable without any arguments. When you call the next
    method, the iterator should return its “next value.” If the method is called,
    and the iterator has no more values to return, it should raise a *StopIteration*
    exception.

    #+BEGIN_CENTER
    *Note:* The iterator protocol is changed a bit in Python 3.0. In the new
    protocol, iterator objects should have a method called *__next__* rather than
    *next* , and a new built-in function called *next* may be used to access this
    method. In other words, *next(it)* is the equivalent of the pre-3.0 *it.next()*.
    #+END_CENTER

    An iterator for these could be the following:

    #+BEGIN_SRC python
    class Fibs:
        def __init__(self):
            self.a = 0
            self.b = 1
        def next(self):
            self.a, self.b = self.b, self.a+self.b
            return self.a
        def __iter__(self):
            return self
    #+END_SRC

    #+BEGIN_CENTER
    *Tip* The built-in function iter can be used to get an iterator from an iterable object:

    >>> it = iter([1, 2, 3])
    >>> it.next()
    1
    >>> it.next()
    2
    #+END_CENTER

*** making sequences from iterators

    #+INCLUDE: "./examples/iterators_sequences.py" src python

** Generators

   A generator is a kind of iterator that is defined with normal function syntax.

*** making a generator

    Making a generator is simple; it's just like making a function. A function that
    flattens nested lists. The argument is a list that may look something like this:

    #+BEGIN_SRC python
    nested = [[1, 2], [3, 4], [5]]
    #+END_SRC

    Here's a solution:

    #+BEGIN_SRC python
    def flatten(nested):
        for sublist in nested:
            for element in sublist:
                yield element
    #+END_SRC

    Any function that contains a *yield* statement is called a generator. And it’s
    not just a matter of naming; it will behave quite differently from ordinary
    functions. The difference is that instead of returning one value, as you do
    with return, you can yield several values, one at a time. Each time a value
    is yielded (with yield), the function /freezes/; that is, it stops its execution
    at exactly that point and waits to be reawakened. When it is, it resumes its
    execution at the point where it stopped.

    #+BEGIN_SRC python
    >>> nested = [[1, 2], [3, 4], [5]]
    >>> for num in flatten(nested):
        print num
        ...
    1
    2
    3
    4
    5
    >>> list(flatten(nested))
    [1, 2, 3, 4, 5]
    #+END_SRC

*** a recursive generator

    #+BEGIN_SRC python
    def flatten(nested):
        try:
            for sublist in nested:
                for element in flatten(sublist):
                    yield element
        except TypeError:
            yield nested
    #+END_SRC

    There is one problem with this, however. If nested is a string-like object
    (string, Unicode, UserString, and so on), it is a sequence and will not
    raise TypeError, yet you do not want to iterate over it.

    #+BEGIN_CENTER
    *Note:* There are two main reasons why you shouldn’t iterate over string-like
    objects in the flatten function. First, you want to treat string-like objects
    as atomic values, not as sequences that should be flattened.Second, /iterating
    over them would actually lead to infinite recursion/ because the first element
    of a string is another string of length one, and the first element of that
    string is the string itself!
    #+END_CENTER

    To deal with this, you must add a test at the beginning of the generator.
    Trying to concatenate the object with a string and seeing if a *TypeError*
    results is the simplest and fastest way to check whether an object is string-like.

    #+BEGIN_SRC python
    def flatten(nested):
        try:
            # Don't iterate over string-like objects:
            try:
                nested + ''
            except TypeError:
                pass
            else:
                raise TypeError
            for sublist in nested:
                for element in flatten(sublist):
                    yield element
        except TypeError:
            yield nested

    #+END_SRC

*** generators in general

    A generator is a function that contains the keyword *yield*. When it is called,
    the code in the function body is not executed. Instead, an iterator is returned.
    Each time a value is requested, the code in the generator is executed until a
    *yield* or a *return* is encoutered. A *yield* means that a value should be yielded.
    A *return* means that the generator should stop executing(without yielding anything
    more; *return* can be called without arguments only when used inside a generator).

    In other words, generators consist of two sepera components: the /generator-function/
    and the /generaotr-iterator/. The generator-function is what is defined by the def
    statement containing a *yield*. The generator-iterator is what this function returns.
    In less precise term, these two entities are often treated as one and collectively
    called a /generator/.

*** generator methods

    A relatively new feature of generators (added in Python 2.5) is the ability to
    supply generators with values after they have started running. This takes the
    form of a communications channel between the generator and the “outside world,”
    with the following two end points:

    + The outside world has access to a method on the generator called *send*, which
    works just like *next*, except that it takes a single argument (the “message” to
    send—an arbitrary object).

    + Inside the suspended generator, *yield* may now be used as an expression, rather
    than a statement. In other words, when the generator is resumed, yield returns
    a value—the value sent from the outside through *send*. If next was used, yield
    returns None.

    Note that using send (rather than next) makes sense only after the generator
    has been suspended (that is, after it has hit the first yield). If you need
    to give some information to the generator before that, you can simply use the
    parameters of the generator-function.

    Here’s a rather silly example that illustrates the mechanism:

    #+BEGIN_SRC python
    def repeater(value):
        while True:
            new = (yield value)
            if new is not None: value = new

    r = repeater(42)
    r.next()
    42
    r.send("Hello, world!")
    "Hello, world!"
    #+END_SRC

    Generators also have two other methods (in Python 2.5 and later):

    + The *throw* method (called with an exception type, an optional value and traceback
    object) is used to raise an exception inside the generator (at the yield expression).

    + The *close* method (called with no arguments) is used to stop the generator.

** The Eight Queens


* Batteries Included

** modules

*** modules are programs

    Any Python program can be imported as a module.
