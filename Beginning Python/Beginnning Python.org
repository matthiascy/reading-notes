#+TITLE:Beginning Python: From Novice to Prefessional
* The Basics
** Numbers and Expressions
   #+BEGIN_SRC python
   >>> 1.0 / 2.0
   0.5

   >>> 1 / 2.0
   0.5

   >>> 1.0 / 2
   0.5

   >>> 1 / 2.
   0.5
   #+END_SRC
   Real numbers are called /floats/ (or /floating-point numbers) in Python. If
   either one of the numbers in a division is a float, the result will be, too:
   If you would rather have Python do proper division, you could add the follwing
   statement to the beginning of your program:
   Another alternative, if you're running Python from the command line, is to supply
   the command-line switch -Qnew. In either case, division will suddenly make a bit
   more sense:
   Of course, the single slash can no longer be used for the kind of integer division
   shown earlier. A separate operator will do this - double slash:

   #+BEGIN_SRC python
   >>> from __future__ import division
   #+END_SRC
   #+BEGIN_SRC python
   >>> 1 / 2
   0.5
   #+END_SRC
   #+BEGIN_SRC python
   >>> 1 // 2
   0
   #+END_SRC
   The double slash conistently perofrms integer division, even with floats:
   #+BEGIN_SRC python
   >>> 1.0 // 2.0
   0.0
   #+END_SRC
   The remainder(modulus) operator x % y gives the remainder of x divided by y,
   and it works just fine with floats as well
   #+BEGIN_SRC python
   >>> 2.75 % 0.5
   0.25
   #+END_SRC
   The exponentiation(or power)operator:
   #+BEGIN_SRC python
   >>> 2 ** 3
   8
   >>> -3 ** 2
   -9
   >>> (-3) ** 2
   9
   #+END_SRC

** Statements
   *Note:* In Python 3.0, *print* is a function, which means you need to
   write print(...) instead of print ...

*** The IF statement
    #+BEGIN_SRC python
    >>> if 1 == 2: print 'One equals two'
    ...
    >>> if 1 == 1: pirnt 'One equals one'
    #+END_SRC

** Modules
   Modules is extensions that can be imported into Python to extend its
   capabilities. You import modules with a special command called(naturally
   enough) *import*.

   If you are sure that you won't import more than one function with a given name,
   you might not want to write the module name each time you call the function.
   Then you can use a variant of the *import* command:
   #+BEGIN_SRC python
   >>> from math import sqrt
   >>> sqrt(9)
   3.0
   #+END_SRC

** cmath and Complex Numbers
   Complex number is covered by a different module, *cmath* (for complex math):
   #+BEGIN_SRC python
   >>> import cmath
   >>> cmath.sqrt(-1)
   1j
   #+END_SRC

** Back to the __future__
   From it, we can import features that will be standard in Python in the future
   but that aren’t part of the language yet.

** Making scripts behave like normal programs
   In UNIX, there is a standard way of doing this: have the first line of your
   script begin with the character sequence #! (called pound bang or shebang)
   followed by the absolute path to the program that interprets the script (in
   our case Python). Even if you didn’t quite understand that, just put the
   following in the first line of your script if you want it to run easily on UNIX:

   #!/usr/bin/env python

   This should run the script, regardless of where the Python binary is located.

   *Note:* In some operating systems if you install a recent version of Python (e.g., 3.0)
   you will still have an old one lying around (e.g.,2.7), which is needed by some
   system programs (so you can’t uninstall it). In such cases, the /usr/bin/env
   trick is not a good idea, as you will probably end up with your programs being
   executed by the old Python. Instead, you should find the exact location of your
   new Python executable (probably called python or python2.7 ) and use the full
   path in the pound bang line, like this:

   #!/usr/bin/python2

   The exact path may vary from system to system.

   Before you can actually run your script, you must make it executable:

   $ chmod a+x hello.py

   Now it can be run like this (assuming that you have the current directory in your path):

   $ hello.py

   If this doesn’t work, try using ./hello.py instead, which will work even if the current
   directory (.) is not part of your execution path.
   If you like, you can rename your file and remove the py suffix to make it look more like a
   normal program.

** Comments
   The hash sign (#) is a bit special in Python. When you put it in your code,
   everything to the right of it is ignored (which is why the Python interpreter
   didn’t choke on the /usr/bin/env stuff used earlier). Here is an example:
   #+BEGIN_SRC python
   # Print the circumference of the circle:
   print 2 * pi * radius
   #+END_SRC

** Strings
*** String Representations, repr and str
   *str* and *repr* simply converts a value into a string, for example, repr creates a
   string that is a representation of the value as a legal Python expressoion.
   #+BEGIN_SRC python
   >>> print repr("Hello, world!")
   'Hello, world!'
   >>> print repr(10000L)
   10000L
   >>> print str("Hello, world!")
   Hello, world!
   >>> print str(10000L)
   10000
   #+END_SRC
   A synonym for repr(x) is `x`(here, you use backticks, not single quotes).
   *Note:* Backticks are removed in Python 3.0.

   In short, *str*, *repr* and backticks are three ways of converting a Python value to a
   string. The function *str* makes it look good, while repr(and the backticks) tries to make
   the resulting string a legal Python expression.

*** input vs. raw_input
   *input* assumes that what you enter is a valid Python expression(it's more or less the inverse
   of *repr*). For example, if you write your name as a string, that's no problem.
   However, it's just a bit too much to as that users write their name in quotes like that. Therefore
   we use *raw_input*,whick treats all input as raw data and puts it into a string.
   #+BEGIN_SRC python
   >>> input("Enter a number: ")
   Enter a number: 3
   3
   >>> raw_input("Enter a number: ")
   Enter a number: 3
   '3'
   #+END_SRC
   *I just thought the numbers in Python are treated as expressions but strings are not, so the
   /raw_input/ is much more like input a string directly otherwise would be treated as a variable.*

*** long strings, raw strings, and unicode
**** long strings
     If you want to write a really long string, one that spans several lines, you can use triple
     quotes instead of ordinary quotes.

     *Tip:*
     Ordinary strings can span several lines only if  the last character on a line is a backslash.

**** raw strings
     *Raw strings* is useful when you trying to input a long pathname, like this:
     #+BEGIN_SRC python
     path = 'C:\\Programm Files\\fnord\\foo\\bar\\baz\\frozz\\bozz'
     #+END_SRC
     which with lots of backslashes. Here is using raw string:
     #+BEGIN_SRC python
     path = r'C:\Program Files\fnord\foo\bar\baz\frozz\bozz'
     #+END_SRC
     The last character in a raw string cannot be a backslash unless you escape it(and then the
     backslash you use to escape it will be part of the string, too). What if you want the last
     character in raw string to be a backslash?
     #+BEGIN_SRC python
     path = r'C:\Program Files\fnord\foo\bar\baz\frozz\bozz' '\\'
     #+END_SRC

**** unicode strings
     #+BEGIN_SRC python
     u'hello, world'
     #+END_SRC
     *Note:* In Python 3.0, all strings will be Unicode strins.

** new functions by now
   |--------------------------+------------------------------------------------------------|
   | function                 | description                                                |
   |--------------------------+------------------------------------------------------------|
   | abs(number)              | Returns teh absolute value of a number                     |
   |--------------------------+------------------------------------------------------------|
   | cmath.sqrt(number)       | Returns the square root; works with negative numbers       |
   |--------------------------+------------------------------------------------------------|
   | float(object)            | Converts a string or number to a floating-point number     |
   |--------------------------+------------------------------------------------------------|
   | help()                   | Offers interactive help                                    |
   |--------------------------+------------------------------------------------------------|
   | input(prompt)            | Gets input from the user                                   |
   |--------------------------+------------------------------------------------------------|
   | int(object)              | Converts a string or number to an integer                  |
   |--------------------------+------------------------------------------------------------|
   | long(object)             | Converts a string or number to a long integer              |
   |--------------------------+------------------------------------------------------------|
   | math.ceil(number)        | Returns the ceiling of a number as a float                 |
   |--------------------------+------------------------------------------------------------|
   | math.floor(number)       | Returns the floor of a number as a float                   |
   |--------------------------+------------------------------------------------------------|
   | math.sqrt(number)        | Return the square root; doesn't work with negative numbers |
   |--------------------------+------------------------------------------------------------|
   | pow(x, y[, z])           | Return s x to the power of y(modulo z)                     |
   |--------------------------+------------------------------------------------------------|
   | raw_input(prompt)        | Gets input from the user, as a string                      |
   |--------------------------+------------------------------------------------------------|
   | repr(object)             | Retrurns a string representation of a value                |
   |--------------------------+------------------------------------------------------------|
   | round(number[, ndigits]) | Rounds a number to a given precision                       |
   |--------------------------+------------------------------------------------------------|
   | str(object)              | Converts a value to string                                 |
   |--------------------------+------------------------------------------------------------|
* Lists and Tuples
   The most basic data structure in Python is the *sequence*. Each element of a
   sequence is assigned a number-its position, or /index/. The first index is
   zero, the second index is one, and so forth.

   *Note:* The last item of sequence is numbered -1, the next-to-last -2, and so
   forth. That means you can count forward /or/ backward from the first element,
   which lies at the beginning, or 0.

** sequence overview
   Python has siz built-in types of sequences. They are *lists*, *tuples*,
   *strings*, *Unicode strings*, *buffer objects* and *xrange objects*.

   The main difference between lists and tuples is that you can change a list,
   but you can't change a tuple.
   #+BEGIN_SRC python
   >>> edward = ['Edward Gumby', 42]
   #+END_SRC
   Swquences can contain other sequences, too.
   #+BEGIN_SRC python
   >>> edward = ['Edward Gumby', 42]
   >>> john = ['Jhon Smith', 50]
   >>> database = [edward, john]
   >>> database
   [['Edward Gumby', 42], ['John Smith', 50]]
   #+END_SRC

*** common sequence operations
    These operations include /indexin/, /slicig/, /adding/, /multiplying/,
    /iteration/ and checking for /membership/. In addtion, Python has built-in
    functions for finding the length of a sequence, and for finding its largest
    and smallest elements.

    To iterate over a sequence means to perform certain actions repeatedly, once
    per element in the sequence.

**** indexing
     All elements in a sequence are numbered—from zero and upwards. You can access
     them individually with a number, just like an array.

     *Note:* A string is just a sequence of characters.

     If a function call returns a sequence, you can index it directly. For instance,
     if you are simply interested in the fourth digit in a year entered by the user,
     you could do something like this:
     #+BEGIN_SRC python
     >>> fourth = raw_input('Year: ')[3]
     Year: 2005
     >>> fourth
     '5'
     #+END_SRC
     [[file:examples/indexing.py][Example]]

**** slicing
     You can use /slicing/ to access ranges of elements. Do this by using /two/ indices,
     separated by a colon:
     #+BEGIN_SRC python
     >>> tag = '<a href="http://www.python.org">Python web site</a>'
     >>> tag[9:30]
     'http://www.python.org'
     >>> tag[32:-4]
     'Python web site'
     #+END_SRC
     The /first/ index is the number of the first element you want to include. However,
     the /last/ index is the number of the first element /after/ your slice.
     In short, you supply two indices as limits for your slice, where the first is
     *inclusive* and the second is *exclusive*.
     #+BEGIN_SRC python
     >>> numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
     >>> numbers[3:6]
     [4, 5, 6]
     >>> numbers[-3:]
     [8, 9, 10]
     >>> numbers[:3]
     [1, 2, 3]
     >>> numbers[:]
     [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
     #+END_SRC
     [[file:examples/slicing.py][Example]]

***** longer steps
      When slicing, you specify (either explicitly or implicitly) the start and end points
      of the slice. Another parameter which normally is left implicit, is the step length.
      In a regular slice, the step length is one, which means that the slice “moves” from
      one element to the next, returning all the elements between the start and end:
      #+BEGIN_SRC python
      >>> numbers[0:10:1]
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
      >>> numbers[0:10:2]
      [1, 3, 5, 7, 9]
      #+END_SRC
      Still can use the shortcuts mentioned earlier.
      #+BEGIN_SRC python
      >>> numbers[::4]
      [1, 5, 9]
      #+END_SRC
      Naturally, the step size can't be zero, but it can be negative, which means extracting
      the elements form right to left:
      #+BEGIN_SRC python
      >>> numbers[8:3:-1]
      [9, 8, 7, 6, 5]
      #+END_SRC

**** adding sequences
     Sequences can be concatenated with the addition(plus) operator:
     #+BEGIN_SRC python
     >>> 'Hello, ' + 'world!'
     'Hello, world!'
     #+END_SRC
     But, you can’t concatenate a list and a string, although both are sequences. In general,
     you cannot concatenate sequences of different types.

**** multiplication
     Multiplying a sequence by a number x creates a new sequence where the original sequence is
     repeated x times:
     #+BEGIN_SRC python
     >>> 'python' * 5
     'pythonpythonpythonpythonpython'
     >>> [42] * 10
     [42, 42, 42, 42, 42, 42, 42, 42, 42, 42]
     #+END_SRC

***** none, empty lists, and initialization
      An empty list is simply written as two brackets ([]) - there's nothing in it. None is a
      Python value and means exactly that—"nothing here". So if you want to initialize a list
      of length 10, you could do the following:
      #+BEGIN_SRC python
      >>> sequence = [None] * 10
      >>> sequence
      [None, None, None, None, None, None, None, None, None, None]
      #+END_SRC
      [[file:examples/sequence_multiplication.py][Example]]

**** membership
     To check whether a value can be found in a sequence, you use the *in* operator.
     It checks whether something is true and returns a value accordingly: True for
     true and False for false.
     #+BEGIN_SRC python
     >>> permissions = 'rw'
     >>> 'w' in permissions
     True
     >>> 'x' in permissionsCHAPTER 2 ■ LISTS AND TUPLES
     False
     >>> users = ['mlh', 'foo', 'bar']
     >>> raw_input('Enter your user name: ') in users
     Enter your user name: mlh
     True
     >>> subject = '$$$ Get rich now!!! $$$'
     >>> '$$$' in subject
     True
     #+END_SRC
     [[file:examples/sequence_membership.py][Example]]

**** length, minimum, and maximum
     #+BEGIN_SRC python
     >>> numbers = [100, 34, 678]
     >>> len(numbers)
     3
     >>> max(numbers)
     678
     >>> min(numbers)
     34
     >>> max(2, 3)
     3
     >>> min(9, 3, 2, 5)
     2
     #+END_SRC

*** lists
    list are /mutable/ - that is, you can change their contents - and they have
    many useful specialized methods.

**** function
     #+BEGIN_SRC python
     >>> list('Hello')
     ['H', 'e', 'l', 'l', 'o']
     #+END_SRC
     *list* works with all kinds of sequences, not just strings.

     *Tip:* To convert a list of characters such as the preceding code back to
     string, you would use the following expression:
     #+BEGIN_SRC python
     ''.join(somelist)
     #+END_SRC
     where some list is you list.

**** basic operations
     You can perform all the standard sequence operations on lists.

***** changing lists: item assignments
      #+BEGIN_SRC python
      >>> x = [1, 1, 1]
      >>> x[1] = 2
      >>> x
      [1, 2, 1]
      #+END_SRC
      *Note:* You cannot assign to a postion that doesn't exist.

***** deleting elements
      You can simply use the *del* statement:
      #+BEGIN_SRC python
      >>> names = ['Alice', 'Beth', 'Cecil', 'Dee-Dee', 'Earl']
      >>> del names[2]
      >>> names
      ['Alice', 'Beth', 'Dee-Dee', 'Earl']
      #+END_SRC

***** assigning to slices
      #+BEGIN_SRC python
      >>> name = list('Perl')
      >>> name
      ['P', 'e', 'r', 'l']
      >>> name[2:] = list('ar')
      >>> name
      ['P', 'e', 'a', 'r']
      #+END_SRC
      You can assign to several positions at once.
      #+BEGIN_SRC python
      >>> name = list('Perl')
      >>> name[1:] = list('ython')
      >>> name
      ['P', 'y', 't', 'h', 'o', 'n']
      #+END_SRC
      Slice assignments can even be used to insert elements without replacing any of the
      original ones:
      #+BEGIN_SRC python
      >>> numbers = [1, 5]
      >>> numbers[1:1] = [2, 3, 4]
      >>> numbers
      [1, 2, 3, 4, 5]
      #+END_SRC

***** list methods
      A method is a function that is tightly coupled to some object, be it a list, a number,
      a string, or whatever. In general, a method is called like this:

      object.method(arguments)

      A method call looks just like a function call, except that the object is put before the
      method name, with a dot separating them.

****** append
       The *append* method is used to append an object to the end of a list:
       #+BEGIN_SRC python
       >>> lst = [1, 2, 3]
       >>> lst.append(4)
       >>> lst
       [1, 2, 3, 4]
       #+END_SRC

****** count
       The *count* method counts the occurrences of an element in a list:
       #+BEGIN_SRC python
       >>> ['to', 'be', 'or', 'not', 'to', 'be'].count('to)
       2
       >>> x = [[1, 2], 1, 1, [2, 1, [1, 2]]]
       >>> x.count(1)
       2
       #+END_SRC

****** extend
       The *extend* method allows you to append several values at once by supplying
       a sequence of the values you want to append. In other words, your original
       list has been extended by the other one:

       #+BEGIN_SRC python
       >>> a = [1, 2, 3]
       >>> b = [4, 5, 6]
       >>> a.extend(b)
       >>> a
       [1, 2, 3, 4, 5, 6]
       #+END_SRC

       This may seem similar to concatenation, but the important difference is that the
       extended sequence(in this case, a) is modified. This is not the case in ordinary
       concatenation, in which a completely new sequence is returned;

       #+BEGIN_SRC python
       >>> a = [1, 2, 3]
       >>> b = [4, 5, 6]
       >>> a + b
       [1, 2, 3, 4, 5, 6]
       >>> a
       [1, 2, 3]
       #+END_SRC

****** index
       The *index* method is used for searching lists to find the index of the first
       occurrence of a value:
       #+BEGIN_SRC python
       >>> knights = ['We', 'are', 'the', 'knights', 'who', 'say', 'ni']
       >>> knights.index('who')
       4
       #+END_SRC

****** insert
       The *insert* method is used to insert an object into a list:

       #+BEGIN_SRC python
       >>> numbers = [1, 2, 3, 5, 6, 7]
       >>> numbers.insert(3, 'four')
       >>> numbers
       [1, 2, 3, 'four', 5, 6, 7]
       #+END_SRC

****** pop
       The *pop* method removes an element(by default, the last one) from the list
       and returns it:

       #+BEGIN_SRC python
       >>> x = [1, 2, 3]
       >>> x.pop()
       3
       >>> x
       [1, 2]
       >>> x.pop(0)
       1
       >>> x
       [2]
       #+END_SRC

****** remove
       The *remove* method is used to remove the first occurence of a value:
       #+BEGIN_SRC python
       >>> x = ['to', 'be', 'or', 'not', 'to', 'be']
       >>> x.remove('be')
       >>> x
       ['to', 'or', 'not', 'to', 'be']
       #+END_SRC

****** reverse
       The *reverse* method reverses the elements in the list.
       #+BEGIN_SRC python
       >>> x = [1, 2, 3]
       >>> x.reverse()
       >>> x
       [3, 2, 1]
       #+END_SRC

       *Tip:* If you want to iterate over a sequence in reverse, you can use the
       reversed function. This function doesn’t return a list, though; it returns
       an iterator. You can convert the returned object with list :
       #+BEGIN_SRC python
       >>> x = [1, 2, 3]
       >>> list(reversed(x))
       [3, 2, 1]
       #+END_SRC

****** sort
       The *sort* method is used to sort lists in place. Sorting "in place" means
       changing the original list so its elements are in sorted order, rather than
       simply returning a sorted copy of the list:

       #+BEGIN_SRC python
       >>> x = [4, 6, 2, 1, 7, 9]
       >>> x.sort()
       >>> x
       [1, 2, 4, 6, 7, 9]
       #+END_SRC

       You’ve encountered several methods already that modify the list without returning any-
       thing, and in most cases that behavior is quite natural (as with append, for example).
       But I want to emphasize this behavior in the case of sort because so many people seem
       to be confused by it. The confusion usually occurs when users want a sorted copy of a
       list while leaving the original alone. An intuitive (but wrong) way of doing this is
       as follows:

       #+BEGIN_SRC python
       >>> x = [4, 6, 2, 1, 7, 9]
       >>> y = x.sort() # Don't do this!
       >>> print y
       None
       #+END_SRC

       Because sort modifies x but returns nothing, you end up with a sorted x and a y
       containing None. One correct way of doing this would be to first bind y to a copy
       of x, and then sort y, as follows:

       #+BEGIN_SRC python
       >>> x = [4, 6, 2, 1, 7, 9]
       >>> y = x[:]
       >>> y.sort()
       >>> x
       [4, 6, 2, 1, 7, 9]
       >>> y
       [1, 2, 4, 6, 7, 9]
       #+END_SRC

       Recall that x[:] is a slice containing all the elements of x, effectively a copy of
       the entire list. Simply assigning x to y wouldn’t work because both x and y would
       refer to the same list:

       #+BEGIN_SRC python
       >>> y = x
       >>> y.sort()
       >>> x
       [1, 2, 4, 6, 7, 9]
       >>> y
       [1, 2, 4, 6, 7, 9]
       #+END_SRC

       Another way of getting a sorted copy of a list is using the *sorted* function:

       #+BEGIN_SRC python
       >>> x = [4, 6, 2, 1, 7, 9]
       >>> y = sorted(x)
       >>> x
       [4, 6, 2, 1, 7, 9]
       >>> y
       [1, 2, 4, 6, 7, 9]
       #+END_SRC

*** tuples: immutables sequences
    Tuples are sequences, just like lists. The only difference is that tuples can’t be
    changed. (As you may have noticed, this is also true of strings.) The tuple syntax
    is simple—if you separate some values with commas, you automatically have a tuple:

    #+BEGIN_SRC python
    >>> 1, 2, 3
    (1, 2, 3)
    #+END_SRC

    tuples may also be (and often are) enclosed in parentheses:
    #+BEGIN_SRC python
    >>> (1, 2, 3)
    (1, 2, 3)
    #+END_SRC

    This is a bit peculiar-you have to include a comma, even though there is
    only one value:
    #+BEGIN_SRC python
    >>> 42
    42
    >>> 42,
    (42,)
    >>> (42,)
    (42,)
    #+END_SRC

    The last two examples produce tuples of length one, while the first is not a
    tuple at all. The comma is crucial. Simply adding parentheses won’t help: (42)
    is exactly the same as 42. One lonely comma, however, can change the value of
    an expression completely:
    #+BEGIN_SRC python
    >>> 3*(40+2)
    126
    >>> 3*(40+2,)
    (42, 42, 42)
    #+END_SRC

**** function
     The tuple function works in pretty much the same way as list: it takes one sequence argument
     and converts it to a tuple. If the argument is already a tuple, it is returned unchanged:

     #+BEGIN_SRC python
     >>> tuple([1, 2, 3])
     (1, 2, 3)
     >>> tuple('abc')
     ('a', 'b', 'c')
     >>> tuple((1, 2, 3))
     (1, 2, 3)
     #+END_SRC

** new functions
   |---------------+-------------------------------------------------------|
   | function      | description                                           |
   |---------------+-------------------------------------------------------|
   | cmp(x, y)     | Compares two values                                   |
   |---------------+-------------------------------------------------------|
   | len(seq)      | Returns the length of a sequence                      |
   |---------------+-------------------------------------------------------|
   | list(seq)     | Converts a sequence to a list                         |
   |---------------+-------------------------------------------------------|
   | max(args)     | Returns the maximum of a sequence or set of arguments |
   |---------------+-------------------------------------------------------|
   | min(args)     | Returns the minimum of a sequence or set of arguments |
   |---------------+-------------------------------------------------------|
   | reversed(seq) | Lets you iterate over a sequence in reverse           |
   |---------------+-------------------------------------------------------|
   | sorted(seq)   | Returns a sorted list of the elements of seq          |
   |---------------+-------------------------------------------------------|
   | tuple(seq)    | Converts a sequence to a tuple                        |
   |---------------+-------------------------------------------------------|

* Strings
** basic operations
   All the standard sequence operations(indexing, slicing, multiplication,
   membership, length, minimum, and maximum) work with strings. Strings are
   immutable, so all kinds of item or slice assignments are illegal:
   #+BEGIN_SRC python
   >>> website = 'http://www.python.org'
   >>> website[-3:] = 'com'
   Traceback (most recent call last):
     File "<pyshell#19>", line 1, in ?
       website[-3:] = 'com'
   TypeError: object doesn't support slice assignment
   #+END_SRC

** string formatting: the short version
   String formatting uses the (aptly named) string formatting operator, the
   percent (%) sign. To the left of the %, you place a string (the format string);
   to the right of it, you place the value you want to format.
   #+BEGIN_SRC python
   >>> format = "Hello, %s. %s enough for ya?"
   >>> values = ('world', 'Hot')
   >>> print format % values
   Hello, world. Hot enough for ya?
   #+END_SRC

   *Note:* If you use a list or some other sequence instead of a tuple, the sequence
   will be interpreted as single value. Only tuples and dictionaries will allow you
   to format more than one value.

   The %s parts of the format string are called /conversion specifiers/. They mark the
   places where the values are to be inserted.

*** template strings
    The string module offers another way of formatting values: template strings. They
    work more like variable substitution in many UNIX shells, with $foo being replaced
    by a keyword argument called foo, which is passed to the template method substitute:

    #+BEGIN_SRC python
    >>> from string import Template
    >>> s = Template('$x, glorious $x!')
    >>> s.substitute(x='slurm')
    'slurm, glorious slurm!'
    #+END_SRC

    If the replacement field is part of a word, the name must be enclosed in braces, in
    order to clearly indicate where it ends:

    #+BEGIN_SRC python
    >>> s = Template("It's ${x}tastic!")
    >>> s.substitute(x='slurm')
    "It's slurmtastic!"
    #+END_SRC

    In order to insert a dollar sign, use $$:

    #+BEGIN_SRC python
    >>> s = Template("Make $$ selling $x!")
    >>> s.substitute(x='slurm')
    'Make $ selling slurm!'
    #+END_SRC

    Instead of using keyword arguments, you can supply the value-name pairs in a dictionary:

    #+BEGIN_SRC python
    >>> s = Template('A $thing must never $action.')
    >>> d = {}
    >>> d['thing'] = 'gentleman'
    >>> d['action'] = 'show his socks'
    >>> s.substitute(d)
    'A gentleman must never show his socks.'
    #+END_SRC

    There is also a method called safe_substitute that will not complain about
    missing values or incorrect uses of the $ character.

** string formatting: the long version
*** conversion specifier
    A basic conversion specifier consists of the items that follow. Note that the order
    of these items is crucial.

    * *The % character:* This marks the beginning of the conversion specifier.
    * *Conversion flags:* These are optional and may be -, indicating left alignment;
      +, indicating that a sign should precede the converted value; " "(a space character),
      indicating that space should precede positive numbers; or 0, indicating that the
      conversion should be zero-padded.
    * *The minimum field width:* This is also optional and specifies that the converted
      string will be at least this wide. If this is an * (asterisk), the width will be
      read from the value tuple.
    * *A . (dot) followed by the precision:* This is also optional. If a real number is
      converted, this many decimals should be shown. If a string is converted, this number
      is the /maximum field width/. If this is an * (asterisk), the precision will be read
      from the value tuple.
    * *The conversion type:* This can be any of the types listed follow.

    |-----------------+------------------------------------------------------------------------------|
    | conversion type | meaning                                                                      |
    |-----------------+------------------------------------------------------------------------------|
    | d, i            | signed integer decimal                                                       |
    |-----------------+------------------------------------------------------------------------------|
    | o               | unsigned octal                                                               |
    |-----------------+------------------------------------------------------------------------------|
    | u               | unsigned decimal                                                             |
    |-----------------+------------------------------------------------------------------------------|
    | x               | unsigned hexadecimal(lowercase)                                              |
    |-----------------+------------------------------------------------------------------------------|
    | X               | unsigned hexadecimal(uppercase)                                              |
    |-----------------+------------------------------------------------------------------------------|
    | e               | floating-point exponential format(lowercase)                                 |
    |-----------------+------------------------------------------------------------------------------|
    | E               | floating-point exponential format(uppercase)                                 |
    |-----------------+------------------------------------------------------------------------------|
    | f, F            | floating-point decimal format                                                |
    |-----------------+------------------------------------------------------------------------------|
    | g               | same as e if exponent is greater than -4 or less than precision; f otherwise |
    |-----------------+------------------------------------------------------------------------------|
    | G               | same as E if exponent is greater than -4 or less than precision; F otherwise |
    |-----------------+------------------------------------------------------------------------------|
    | c               | single character(accepts an integer or a single character string)            |
    |-----------------+------------------------------------------------------------------------------|
    | r               | string(converts any Python object using repr)                                |
    |-----------------+------------------------------------------------------------------------------|
    | s               | string(converts any Python object using str)                                 |
    |-----------------+------------------------------------------------------------------------------|

*** signs, alignment, and zero-padding
    Before the width and precision numbers, you may put a "flag", which may be either
    zero, plus, minus, or blank. A zero means that the number will be zero-padded:

    #+BEGIN_SRC python
    >>> ‘%010.2' % pi
    '00000003.14'
    #+END_SRC

    A minus sign(-) left-aligns the value:

    #+BEGIN_SRC python
    >>> '%-10.2f' % pi
    '3.14       '
    #+END_SRC

    A blank(" ") means that a blank should be put in front of positive numbers. This
    is useful for aligning positive and negative numbers:

    #+BEGIN_SRC python
    >>> print (' %5d' % 10)
       10
    >>> print ('% 5d' % -10)
      -10
    #+END_SRC

    A plus(+) means that a sign(either plus or minus) should precede both positive
    and negative numbers (again, useful for aligning):

    #+BEGIN_SRC python
    >>> print ('%+5d' % 10) + ('%+5d' % 10)
      +10
      -10
    #+END_SRC

    In the following example, use the asterisk width specifier to format a table of fruit
    prices, where the user enters the total width of the table. [[file:./examples/string_fromatting.py][Example]]

*** string methods
**** find
     The *find* method finds a substring within a larger string. Ite returns
     the leftmost index where the substring is found. If it is /not/ found,
     -1 is returned:

     #+BEGIN_SRC python
     >>> 'With a moo-moo here, and a moo-moo there'.find('moo')
     7
     >>> title = "Monty Python's Flying Circus"
     >>> title.find('Monty')
     0
     >>> title.find('Zirquss')
     -1
     #+END_SRC

     You may also supply a starting point for search and, optionally, an ending point:

     #+BEGIN_SRC python
     >>> subject = '$$$ Get rich now!!! $$$'
     >>> subject.find('$$$')
     0
     >>> subject.find('$$$', 1) #only supplying the start
     20
     >>> subject.find('!!!')
     16
     >>> subject.find('!!!', 0, 16) # supplying start and end
     -1
     #+END_SRC

**** join
     The *join* method is the inverse of *split*. It is use to join the elements of a
     sequence:

     #+BEGIN_SRC python
     >>> seq = [1, 2, 3, 4, 5]
     >>> sep = '+'
     >>> sep.join(seq) # trying to join a list of numbers
     Traceback (most recent call last):
       File "<stdin>", line 1, in ?
     TypeError: sequence item 0: expected string, int found
     >>> seq = ['1', '2', '3', '4', '5']
     >>> sep.join(seq) # joining a list of strings
     '1+2+3+4+5'
     >>> dirs = '', 'usr', 'bin', 'env'
     >>> '/'.join(dirs)
     '/usr/bin/env'
     >>> print 'C:' + '\\'.join(dirs)
     'C:\usr\bin\env'
     #+END_SRC

     *join into is much proper*

**** lower
     The *lower* method returns a lowercase version of the string:

     #+BEGIN_SRC python
     >>> 'Traditional STYLE'.lower()
     'traditional style'
     #+END_SRC

***** title casing
      One relative of *lower* is the *title* method, which title cases a string - that
      is, all words start with uppercase characters, and all other characters are
      lowercased.

      #+BEGIN_SRC python
      >>> "this's all folks".title()
      "That'S All, Folks"
      #+END_SRC

      An alternative is the *capwords* function from the *string* module:

      #+BEGIN_SRC python
      >>> import string
      >>> string.capwords("that's all, folks")
      "That's All, Folks"
      #+END_SRC

**** replace
     The *replace* method returns a string where all the occurrences of one
     string have been replaced by another:

     #+BEGIN_SRC python
     >>> 'This is a test'.replace('is', 'eez')
     'Theez eez a test'
     #+END_SRC

**** split
     A very important string method, *split* is the inverse of *join*, and is used
     to *split* a string into a sequence:

     #+BEGIN_SRC python
     >>> '1+2+3+4+5'.split('+')
     ['1', '2', '3', '4', '5']
     >>> 'usr/bin/env'.split('/')
     ['', 'usr', 'bin', 'env']
     >>> 'Using the default'.split()
     ['Using', 'the', 'default']
     #+END_SRC

     If no separator is supplied, the default is to split on all runs of consecutive
     whitespace characters(spaces, tabs, newlines, and so on).

     *split by is much proper*

**** strip
     The *strip* method returns a string where whitespace on the left and right (but
     not internally) has been stripped (removed):

     #+BEGIN_SRC python
     >>> '        internal whitespace is kept        '.strip()
     'internal whitespace is kept'
     #+END_SRC

**** translate
     Similar to *replace*, *translate* replaces parts of a string, but unlike *replace*,
     *translate* works only with single characters. Its strength lies in that it can
     perform several replacements simultaneously, and can do so more efficiently than
     *replace*.

     Before you can use *translate*, you must make a /translation table/. This translation
     talbe is full listing of which characters should be replaced by which and, you won't
     write it out yourself. Instead, you'll use the function *maketrans* form the *string*
     module.

     The *maketrans* function takes two arguments: two strings of equal length, indicating
     that each character in the first string should be replaced by the character in the
     same postion in the second string.

     #+BEGIN_SRC python
     >>> from string import maketrans
     >>> table = maketrans('cs', 'kz')
     #+END_SRC

     A translation table is a string containing one replacement letter for each of the
     256 characters in the ASCII character set:

     #+BEGIN_SRC python
     >>> table = maketrans('cs', 'kz')
     >>> len(table)
     256
     >>> table[97:123]
     'abkdefghijklmnopqrztuvwxyz'
     >>> maketrans('', '')[97:123]
     'abcdefghijilmnopqrstuvwxyz'
     #+END_SRC

     The empty translation has a normal alphabet, while in the preceding code, the letter c
     has been replaced by k, and s has been replaced by z.

     #+BEGIN_SRC python
     >>> 'this is an incredible test'.translate(table)
     'thiz iz an inkredible tezt'
     #+END_SRC

*** new function
    |----------------------------+-------------------------------------------------------------------------------------|
    | function                   | description                                                                         |
    |----------------------------+-------------------------------------------------------------------------------------|
    | string.capwords(s[, sep])  | splits *s* with *split* (using sep), capitalize items, and join with a single space |
    |----------------------------+-------------------------------------------------------------------------------------|
    | string.maketrans(from, to) | makes a translation table for *tanslate*                                            |
    |----------------------------+-------------------------------------------------------------------------------------|

* Dictionaries
** creating and using dictionaries
   Dictionaries consist of pairs (called /items/) of /keys/ and their corresponding
   /values./ Each key is separated form its value by a colon(:), the items are seperated
   by commas, and the whole thing is enclosed in curly braces. An empty dictionary
   (without any items) is written just two curly bracws, like this {}.

   *Note:* Keys are unique within a dictionary (and any other kind of mapping). Values
   do not need to be unique within a dictionary.

** the *dict* function
   You can use the *dict* function to construct dictionaries from other mappings or from
   sequences of (key, value) pairs:

   #+BEGIN_SRC python
   >>> item = [('name', 'Gumby'), ('age', 42)]
   >>> d = dict(item)
   >>> d
   {'age': 42, 'name': 'Gumby'}
   >>> d['name']
   'Gumby'
   #+END_SRC

   It can also be used with /keyword arguments/, as follows:

   #+BEGIN_SRC python
   >>> d = dict(name='Gumby', age=42)
   >>> d
   {'age': 42, 'name': 'Gumby'}
   #+END_SRC

** basic dictionary operations
   * *len(d)*  returns the number of items (key-value pairs) in *d*.
   * *d[k]* returns the value associated with the key *k*.
   * *d[k] = v* associates the value *v* with the key *k*.
   * *del d[k]* deletes the item with key *k*.
   * *k in d* checks whether there is an item in *d* that has the key *k*.

   Distinctions between dictionaries and lists:

   *Key types:* Dictionary keys don't have toe be integers(though they may be).
   They may be immutable type, such as floating-point(real)numbers, strings, or tuples.

   *Automatic addition:* You can assign a value to a key, even if that key isn't in
   the dictionary to begin with; in that case, a new item will be created. You
   cannot assign a value to an index outside the list's range(without using *append*
   or something like that).

   *Membership:* The expression *k in d*(where *d* is a dictionary)looks for a /key/,
   not a /value/. The expression *v in l*, on the other hand(where *l* is a list)looks
   for a /value/, not an /index/.

   [[file:./examples/dictionary.py][Dictionary Example]]

** string formatting with dictionaries
   If you use a dictionary(with only string and keys) instead of a tuple, you can maek
   the string formatting even snazzier. After the % character in each conversion specifier,
   you add a key(enclosed in parentheses), which is followed by the other specifier elements:

   #+BEGIN_SRC python
   >>> phonebook
   {'Beth': '9102', 'Alice': '2341', 'Ceile': '3258'}
   >>> "Cecil's phone number is %(Cecil)s." % phonebook
   "Cecil's phone number is 3258."
   #+END_SRC

   Using it in template:

   #+BEGIN_SRC python
   >>> template = '''<html>
        <head><title>%(title)s</title></head>
        <body>
        <h1>%(title)s</h1>
        <p>%(text)s</p>
        </body>'''
   >>> data = {'title': 'My Home Page', 'text': 'Welcome to my home page!'}
   >>> print template % data
   <html>
   <head><title>My Hone Page</title></head>
   <body>
   <h1>My Home Page</h1>
   <p>Welcome to my home page!</p>
   </body>
   #+END_SRC

** methods
*** clear
    The *clear* method removes all items from the dictionary. This is an in-place
    operation(like *list.sort*), so it returns nothing(or, rather, *None*):

    #+BEGIN_SRC python
    >>> d = {}
    >>> d['name'] = 'Phill'
    >>> d['age'] = 42
    >>> d
    {'age': 42, 'name': 'Phill'}
    >> returned_value = d.clear()
    >>> d
    {}
    >>> print returned_value
    None
    #+END_SRC

*** copy
    The *copy* method returns a new dictonary with the same key-value pairs(a shallow
    copy, since the values themselves are the /same/, not copies):

    #+BEGIN_SRC python
    >>> x = {'username': 'admin', 'machines': ['foo', 'bar', 'baz']}
    >>> y = x.copy()
    >>> y['username'] = 'mlh'
    >>> y['machines'].remove('bar')
    >>> y
    {'username': 'mlh', 'machines': ['foo', 'baz']}
    >>> x
    {'username': 'admin', 'machines': ['foo', 'baz']}
    #+END_SRC

    When you replace a value in the copy, the original is unaffected. However, if
    you /modify/ a value (in place, without replacing it), the original is changed
    as well because the same value is stored there (like the 'machines' list in this
    example).

    One way to avoid that problem is to make a *deep copy*, you accomplish this using
    the function *deepcopy* from the copy module:

    #+BEGIN_SRC python
    >>> from copy import deepcopy
    >>> d = {}
    >>> d['names'] = ['Alfred', 'Bertrand']
    >>> c = d.copy()
    >>> dc = deepcopy(d)
    >>> d['names'].append('Clive')
    >>> c
    {'names': ['Alfred', 'Bertrand', 'Clive']}
    >>> dc
    {'names': ['Alfred', 'Bertrand']}
    #+END_SRC

*** fromkeys
    The *fromkeys* method creates a new dictionary with the given keys, each with a
    default corresponding value of *None*:

    #+BEGIN_SRC pyhon
    >>> {}.fromkeys(['name', 'age'])
    {'age': None, 'name': None}
    #+END_SRC

    Instead, you can call the method directly on dict, which (as mentioned before)
    is the type of all dictionaries.

    #+BEGIN_SRC python
    >>> dict.fromkeys(['name', 'age'])
    {'age': None, 'name': None}
    #+END_SRC

    If you don’t want to use None as the default value, you can supply your own default:
    #+BEGIN_SRC python
    >>> dict.fromkeys(['name', 'age'], '(unknown)')
    {'age': '(unknown)', 'name': '(unknown)'}
    #+END_SRC

*** get
    The *get* method is a forgiving way of a accessing dictionary items. Ordinarily,
    when you try to access an item that is not present in the dictionary, things go
    very wrong:

    #+BEGIN_SRC python
    >>> d = {}
    >>> print d['name']
    Traceback (most recent call last):
      File "<stdin>", line 1, in ?
    KeyError: 'name'
    #+END_SRC

    Not so with get:

    #+BEGIN_SRC python
    Not so with get:
    >>> print d.get('name')
    None
    #+END_SRC

    As you can see, when you use get to access a nonexistent key, there is no exception.
    Instead, you get the value None. You may supply your own “default” value, which is
    then used instead of None:

    #+BEGIN_SRC python
    >>> d.get('name', 'N/A')
    'N/A'
    #+END_SRC

    If the key is there, get works like ordinary dictionary lookup:

    #+BEGIN_SRC python
    >>> d['name'] = 'Eric'
    >>> d.get('name')
    'Eric'
    #+END_SRC
    [[file:./examples/dictionary_method.py][Dictionary Method Example]]

*** has_key
    The *has_key* method checks whether a dictionary has a given key. The
    expression *d.has_key(k)* is euivalent to *k in d*.

    #+BEGIN_SRC python
    >>> d = {}
    >>> d.has_key('name')
    False
    >>> d['name'] = 'Eric'
    >>> d.has_key('name')
    True
    #+END_SRC

*** items and iteritems
    The *items* method returns all the items of the dictionary as a list of
    items in which each item is of the form(key, value). The items are not
    returnd in any particular order:

    #+BEGIN_SRC python
    >>> d = {'title': 'Python Web Site', 'url': 'http://www.python.org', 'spam': 0}
    >>> d.items()
    [('url', 'http://www.python.org'), ('spam', 0), ('title', 'Python Web Site')]
    #+END_SRC

    The *iteritems* method works in much the same way, but returns an /iterator/
    instead of a list:

    #+BEGIN_SRC python
    >>> it = d.iteritems()
    >>> it
    <dictionary-iterator object at 0x7ff15c3c35d0>
    >>> list(it) # Convert the iterator to a list
    [('url', 'http://www.python.org'), ('spam', 0), ('title', 'Python Web Site')]
    #+END_SRC

*** keys and iterkeys
    The *keys* method returns a list of the keys in the dictionary, while *iterkeys*
    returns an iterator over the keys.

*** pop
    The *pop* method can be used to get the value corresponding to a given key, and
    then remove the key-value pair from the dictionary:

    #+BEGIN_SRC python
    >>> d = {'x': 1, 'y': 2}
    >>> d.pop('x')
    1
    >>> d
    {'y': 2}
    #+END_SRC

*** popitem
    The *popitem* method is similar to *list.pop*, which pops off the last
    element of a list. Unlike *list.pop*, however *popitem* pops off an arbirary
    item because dictionaries don't have a "last element" or any order whatsoever.
    This may be very useful if you want to remve and process the items one by one
    in an efficient way(without retrieving a list of the keys first):

    #+BEGIN_SRC python
    >>> d
    {'url': 'http://www.python.org', 'spam': 0, 'title': 'Python Web Site'}
    >>> d.popitem()
    ('url', 'http://www.python.org')
    >>> d
    {'spam': 0, 'title': 'Python Web Site'}
    #+END_SRC

    Although *popitem* is similar to the list method *pop*, there is no dictionary
    equivalent of *append* (which adds an element to the end of a list).

*** setdefault
    The *setdefault* method is somewhat similar to *get*, in that it retrives a valve
    associated with a given key. In addition to the *get* functionality, *setdefault*
    /sets/ the value corresponding to the given key if it is not already in the
    dictionary:

    #+BEGIN_SRC python
    >>> d = {}
    >>> d.setdefault('name', 'N/A')
    'N/A'
    >>> d
    {'name': 'N/A'}
    >>> d['name'] = 'Gumby'
    >>> d.setdefault('name', 'N/A')
    'Gumby'
    >>> d
    {'name': 'Gumby'}
    #+END_SRC

    As you can see, when the key is missing, *setdefault* returns the default and updates
    the dictionary accordingly. If the key is present, its value is retruned and the
    dictionary is left unchanged. The defalut is optional, as with *get*; if it is left
    out, None is used.

*** update
    The *update* method updates one dictionary with the items of another:

    #+BEGIN_SRC python
    >>> d = {
           'title': 'Python Web Site',
           'url': 'http://www.python.org',
           'changed': 'Mar 14 22:09:15 MET 2008'
        }
    >>> x = {'title': 'Python Language Website'}
    >>> d.update(x)
    >>> d
    {'url': 'http://www.python.org', 'changed':
    'Mar 14 22:09:15 MET 2008', 'title': 'Python Language Website'}
    #+END_SRC

    The *update* method can be called in the same way as the *dict* function(or type
    constructor), as discussed earlier in this chapter. This means that *update* can be called
    with a mapping, a sequence(or other iterable object) of (key, value) pairs, or keyword
    arguments.

*** values and itervalues
    The *values* method returns a list of the values in the dictionary(and *itervalues*
    returns an iterator of the values). Unlike *keys*, the list returned by *values* may
    contain duplicates:

    #+BEGIN_SRC python
    >>> d = {}
    >>> d[1] = 1
    >>> d[2] = 2
    >>> d[3] = 3
    >>> d[4] = 1
    >>> d.values()
    [1, 2, 3, 1]
    #+END_SRC

** new functions
   |-----------+----------------------------------------------------------------------------|
   | function  | description                                                                |
   |-----------+----------------------------------------------------------------------------|
   | dict(seq) | creats diction from (key, value) pairs (or a mapping or keyword arguments) |
   |-----------+----------------------------------------------------------------------------|

* Conditionals, Loops, and some other statements
** printing with commas
   You can actually print more than one expression, as long as you separate
   them with commas:

   #+BEGIN_SRC python
   >>> print 'Age:', 42
   Age: 42
   #+END_SRC

   As you can see, a space character is inserted between each argument.
   *Note:* The arguments of *print* do /not/ form a tuple, as one might
   expect:
   #+BEGIN_SRC python
   >>> 1, 2, 3
   (1, 2, 3)
   >>> print 1, 2, 3
   1 2 3
   >>> print (1, 2, 3)
   (1, 2, 3)
   #+END_SRC

   If you add a comma at the end, your next print statement will continue
   printing on the same line. For example, the statements

   #+BEGIN_SRC python
   print 'Hello,',
   print 'world!'
   #+END_SRC

** importing something as something else
   Usually, when you import something from a module, you either use

   #+BEGIN_SRC python
   import somemodule
   #+END_SRC

   or

   #+BEGIN_SRC python
   from somemodule import somefunction
   #+END_SRC

   or

   #+BEGIN_SRC python
   from somemodule import somefunciton, anotherfunction, yetanotherfunction
   #+END_SRC

   or

   #+BEGIN_SRC python
   from somemodule import *
   #+END_SRC

   But what if you have two modules, each containing a function called
   *open*, for example--what do you do then? You could simply import the
   modules using the first form, and then use the functions as follows:

   #+BEGIN_SRC python
   module1.open(...)
   module2.open(...)
   #+END_SRC

   But there is another option: add an *as* clause to the end and supply
   the name you want to use, either for the entire module:

   #+BEGIN_SRC python
   >>> import math as foobar
   >>> foobar.sqrt(4)
   2.0
   #+END_SRC

   or for the given function:

   #+BEGIN_SRC python
   >>> from math import sqrt as foobar
   >>> foobar(4)
   2.0
   #+END_SRC

** assignment magic
*** sequence unpacking
   You can perform several different assignments /simultaneously/:

   #+BEGIN_SRC python
   >>> x, y, z = 1, 2, 3
   >>> print x, y, z
   1 2 3
   #+END_SRC

   Well, you can use it to switch the contents of two(or more) variables:

   #+BEGIN_SRC python
   >>> x, y = y, x
   >>> print x, y, z
   2 1 3
   #+END_SRC

   Here is called *sequence unpacking(or iterable unpacking)*. I have a
   sequence (or an arbitrary iterable object) of values, and I unpack it
   into a sequence of variables.

   #+BEGIN_SRC python
   >>> values = 1, 2, 3
   >>> values
   (1, 2, 3)
   >>> x, y, z = values
   >>> x
   1
   #+END_SRC

   This allows functions to return more than one value, packed as a tuple, easily
   accessible through a single assignment. The sequence you unpack must have exactly
   as many items as the targets you list on the left of the = sign; otherwise Python
   raises an exception when the assignment is performed:

   #+BEGIN_SRC python
   >>> x, y, z = 1, 2
   Traceback (most recent call last):
     File "<stdin>", line 1, in <module>
   ValueError: need more than 2 values to unpack
   >>> x, y, z = 1, 2, 3, 4
   Traceback (most recent call last):
     File "<stdin>", line 1, in <module>
   ValueError: too many values to unpack
   #+END_SRC

   *Note:* Python 3.0 has another unpacking feature: you can use the star operator(*),
   just as in function argument lists. For example, a, b, rest* = [1, 2, 3, 4] will result
   in *rest* gathering whatever remains after assigning calues to *a* and *b*. In
   this case, *reset* will be [3, 4].

*** chained assignments
    Chained assignments are used as a shortcut when you want to bind several variables
    to the same value. This may seem a bit like the simultaneous assignments, except
    that here you are dealing with only one value:

    #+BEGIN_SRC python
    x = y = somefunction()
    #+END_SRC

    which is the same as

    #+BEGIN_SRC python
    y = somefunction()
    x = y
    #+END_SRC

*** augemented assignments
    #+BEGIN_SRC python
    >>> x = 2
    >>> x += 1
    >>> x *=2
    >>> x
    6
    #+END_SRC

** blocks
   A block is a group of statements that can be executed if a condition is true
   (conditional statements), or executed several times (loops), and so on. A
   block is created by indenting a part of your code; that is, putting spaces in
   front of it.

   *Note:* You can use tab characters to indent your blocks as well. Python interprets
   a tab as moving to the next tab stop, with one tab stop every eight spaces, but
   the standard and preferable style is to use spaces only, not tabs, and specifically
   four spaces per each level of indentation.

   In many languages, a special word or character (for example, begin or {) is used
   to start a block, and another (such as end or }) is used to end it. In Python, a
   colon (:) is used to indicate that a block is about to begin, and then every line
   in that block is indented (by the same amount). When you go back to the same amount
   of indentation as some enclosing block, you know that the current block has ended.

** conditions and conditional statements
*** boolean values
    The following values are considered by the interpreter to mean false when
    evaluated as a Boolean expression (for example, as the condition of an if
    statement):

    False    None    0    ""    ()    []    {}

*** conditional execution and the *if* statement
    There is a tiny difference compared with other languages, the
    *else if* in other language is *elif* in pyhon.

**** comparison operators
     |------------+--------------------------------------|
     | expression | description                          |
     |------------+--------------------------------------|
     | x == y     | x /equals/ y                         |
     |------------+--------------------------------------|
     | x < y      | x is /less than/ y                   |
     |------------+--------------------------------------|
     | x > y      | x is /greater than/ y                |
     |------------+--------------------------------------|
     | x >= y     | x is /greater than or equal to/ y    |
     |------------+--------------------------------------|
     | x <= y     | x is /less than or equal to/ y       |
     |------------+--------------------------------------|
     | x != y     | x is /not equal to/ y                |
     |------------+--------------------------------------|
     | x is y     | x and y are the same object          |
     |------------+--------------------------------------|
     | x is not y | x and y are different objects        |
     |------------+--------------------------------------|
     | x in y     | x is a member of the container y     |
     |------------+--------------------------------------|
     | x not in y | x is not a member of the container y |
     |------------+--------------------------------------|

     Comparisons can be /chained/ in Python, just like assignments -- you can put
     several comparison operators in a chain, like this: 0 < age < 100.

     *Tip:* When comparing things, you can also use the built-in function *cmp*.

     *is* tests for *identity*, rather than *equality*.

*** assertions
    There is a useful relative of the if statement, which works more or less like this
    (pseudocode):

    if not condition:
        crash program

    Basically, you can require that certain things be true (for example, when
    checking required properties of parameters to your functions or as an aid
    during initial testing and debugging). The keyword used in the statement
    is *assert*:

    #+BEGIN_SRC python
    >>> age = 10
    >>> assert 0 < age < 100
    >>> age = -1
    >>> assert 0 < age < 100
    Traceback (most recent call last):
      File "<stdin>", line 1, in ?
    AssertionError
    #+END_SRC

    It can be useful to put the assert statement in your program as a checkpoint, if you know
    something must be true for your program to work correctly.
    A string may be added after the condition, to explain the assertion:

    #+BEGIN_SRC python
    >>> age = -1
    >>> assert 0 < age < 100, 'The age must be realistic'
    Traceback (most recent call last):
      File "<stdin>", line 1, in ?
    AssertionError: The age must be realistic
    #+END_SRC

*** loops
**** *while* loop
     nothing unique compared with other languages.

**** *for* loop
     *in* is a useful expression:

     #+BEGIN_SRC python
     words = ['this', 'is', 'an', 'ex', 'parrot']
     for word in words:
     print word
     #+END_SRC

     Python has a built-in function to make ranges for you:
     #+BEGIN_SRC python
     >>> range(0, 10)
     [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
     >>> range(10)
     [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
     #+END_SRC

     The following program writes out the numbers from 1 to 100:

     #+BEGIN_SRC python
     for number in range(1, 101):
         print number
     #+END_SRC

**** iterating over dictionaries
     #+BEGIN_SRC python
     d = {'x': 1, 'y': 2, 'z': 3}
     for key in d:
         print key, 'corresponds to', d[key]
     #+END_SRC

**** iteration utilities
***** parallel iteration
      Sometimes you want to iterate over two sequences at the same time.
      Let’s say that you have the following two lists:

      #+BEGIN_SRC python
      names = ['anne', 'beth', 'george', 'damon']
      ages = [12, 45, 32, 102]
      #+END_SRC

      If you want to print out names with corresponding ages, you could do the following:

      #+BEGIN_SRC python
      for i in range(len(names)):
          print names[i], 'is', ages[i], 'years old'
      #+END_SRC

      Here, i serves as a standard variable name for loop indices (as these
      things are called).

      A useful tool for parallel iteration is the built-in function *zip*, which "zips"
      together the sequences, returning a list of tuples:

      #+BEGIN_SRC python
      >>> zip(names, ages)
      [('anne', 12), ('beth', 45), ('george', 32), ('damon', 102)]
      #+END_SRC

      Now I can unpack the tuples in my loop:

      #+BEGIN_SRC python
      for name, age in zip(names, ages):
          print name, 'is', age, 'years old'
      #+END_SRC

***** numbered iteration
      In some cases, you want to iterate over a sequence of objects and at the same
      time have access to the index of the current object.

      #+BEGIN_SRC python
      for string in strings:
          if 'xxx' in string:
              index = strings.index(string) # Search for the string in the list of strings
              strings[index] = '[censored]'
      #+END_SRC

      A better version would be the following:

      #+BEGIN_SRC python
      index = 0
      for string in strings:
          if 'xxx' in string:
              strings[index] = '[censored]'
              index += 1
      #+END_SRC

      This also seems a bit awkward, although acceptable. Another solution is to use
      the built-in function *enumerate*:

      #+BEGIN_SRC python
      for index, string in enumerate(strings):
          if 'xxx' in string:
              strings[index] = '[censored]'
      #+END_SRC

      This function lets you iterate over index-value pairs, where the indices are
      supplied automatically.

***** reversed and sorted iteration
      *reversed* and *sorted*, they're similar to the list methods *reverse* and *sort*,
      but they work on any sequence or iterable object, and instead of modifying the
      object in place, they return reversed and sorted versions:

      #+BEGIN_SRC python
      >>> sorted([4, 3, 6, 8, 3])
      [3, 3, 4, 6, 8]
      >>> sorted('Hello, world!')
      [' ', '!', ',', 'H', 'd', 'e', 'l', 'l', 'l', 'o', 'o', 'r', 'w']
      >>> list(reversed('Hello, world!'))
      ['!', 'd', 'l', 'r', 'o', 'w', ' ', ',', 'o', 'l', 'l', 'e', 'H']
      >>> ''.join(reversed('Hello, world!'))
      '!dlrow ,olleH'
      #+END_SRC

**** breaking out of loops
***** break
      To end (break out of) a loop, you use *break*.

***** continue
      The continue statement is used less often than break. It causes the
      current iteration to end, and to “jump” to the beginning of the next. It
      basically means “skip the rest of the loop body, but don’t end the loop.”

*** list comprehension
    List comprehension is a way of making lists from other lists. It works in a
    way similar to for loops and is actually quite simple:

    #+BEGIN_SRC python
    >>> [x*x for x in range(10)]
    [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
    #+END_SRC

    You can also add more for parts:

    #+BEGIN_SRC python
    >>> [(x, y) for x in range(3) for y in range(3)]
    [(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)]
    #+END_SRC

*** *pass*, *del*, and *exec*
**** pass
    Sometimes you need to do nothing. This may not be very often, but when it
    happens, it’s good to know that you have the pass statement:

    #+BEGIN_SRC python
    >>> pass
    >>>
    #+END_SRC

    Now, why on earth would you want a statement that does nothing? It can be
    useful as a placeholder while you are writing code. For example, you may
    have written an if statement and you want to try it, but you lack the code
    for one of your blocks. Consider the following:

    #+BEGIN_SRC python
    if name == 'Ralph Auldus Melish':
        print 'Welcome!'
    elif name == 'Enid':
        # Not finished yet...
    elif name == 'Bill Gates':
        print 'Access Denied'
    #+END_SRC

    This code won’t run because an empty block is illegal in Python. To fix this,
    simply add a pass statement to the middle block:

    #+BEGIN_SRC python
    if name == 'Ralph Auldus Melish':
        print 'Welcome!'
    elif name == 'Enid':
        # Not finished yet...
        pass
    elif name == 'Bill Gates':
        print 'Access Denied'
    #+END_SRC

**** del
     *del* just delete the /name/, itself(the value). In fact, there is no way to
     delete values in Python -- and you don't realyy need to, because the Python
     interpreter does it by itself whenever you don't use the value anymore.

**** exec and eval
***** exec
     The statement for executing a string is exec:

     #+BEGIN_SRC python
     >>> exec "print 'Hello, world!'"
     Hello, world!
     #+END_SRC

     In most cases, you want to supply it with a namespace—a place where it can put
     its variables. You want to do this so that the code doesn’t corrupt your namespace
     (that is, change your variables). For example, let’s say that the code uses
     the name sqrt:

     #+BEGIN_SRC python
     >>> from math import sqrt
     >>> exec "sqrt = 1"
     >>> sqrt(4)
     Traceback (most recent call last):
       File "<pyshell#18>", line 1, in ?
         sqrt(4)
     TypeError: object is not callable: 1
     #+END_SRC


     The exec statement is mainly useful when you build the code string on the fly.
     And if the string is built from parts that you get from other places, and possibly
     from the user, you can rarely be certain of exactly what it will contain. So to be
     safe, you give it a dictionary, which will work as a namespace for it.

     You do this by adding in <scope>, where <scope> is some dictionary that will function
     as the namespace for your code string:

     #+BEGIN_SRC python
     >>> from math import sqrt
     >>> scope = {}
     >>> exec 'sqrt = 1' in scope
     >>> sqrt(4)
     2.0
     >>> scope['sqrt']
     1
     #+END_SRC

***** eval
      A built-in function that is similar to exec is eval (for “evaluate”). Just
      as exec executes a series of Python statements, eval evaluates a Python
      expression (written in a string) and returns the resulting value. (exec
      doesn’t return anything because it is a statement itself.) For example, you
      can use the following to make a Python calculator:

      #+BEGIN_SRC python
      >>> eval(raw_input("Enter an arithmetic expression: "))
      Enter an arithmetic expression: 6 + 18 * 2
      42
      #+END_SRC

*** new function
    |--------------------------------------+--------------------------------------------------------------------------|
    | function                             | description                                                              |
    |--------------------------------------+--------------------------------------------------------------------------|
    | chr(n)                               | Returns a one-character string when passed ordinal n_ (0dn < 256)        |
    | eval(source[, globals[, locals]])    | Evaluates a string as an expression and returns                the value |
    |--------------------------------------+--------------------------------------------------------------------------|
    | enumerate(seq)                       | Yields (index, value) pairs suitable for iteration                       |
    |--------------------------------------+--------------------------------------------------------------------------|
    | ord(c)                               | Returns the integer ordinal value of a one-character string              |
    |--------------------------------------+--------------------------------------------------------------------------|
    | range([start,] stop[, step])         | Creates a list of integers                                               |
    |--------------------------------------+--------------------------------------------------------------------------|
    | reversed(seq)                        | Yields the values of seq in reverse order, suitable for iteration        |
    |--------------------------------------+--------------------------------------------------------------------------|
    | sorted(seq[, cmp][, key][, reverse]) | Returns a list with the values of seq in sorted order                    |
    |--------------------------------------+--------------------------------------------------------------------------|
    | xrange([start,] stop[, step])        | Creates an xrange object, used for iteration                             |
    |--------------------------------------+--------------------------------------------------------------------------|
    | zip(seq1,_seq2,...)                  | Creates a new sequence suitable for parallel iteration                   |
    |--------------------------------------+--------------------------------------------------------------------------|

* Abstraction
** creating functions
   Define a function with the *def* (or "function definition") statement:

   #+BEGIN_SRC python
   def hello(name):
       return 'Hello, ' + name + '!'
   #+END_SRC
** documenting functions
   If you want to document your functions so that you’re certain that others will
   understand them later on, you can add comments (beginning with the hash sign, #).

   Another way of writing comments is simple to write strings by themselves. Such
   strings can be particularly useful in some places, such as immediately after a
   *def* statement(and at the beginning of a module or a class). If you put a string
   at the beginning of a function, it is stored as part of the function and is called
   a /docstring/. The following code demonstrates how to add a docstring to a function:

   #+BEGIN_SRC python
   def square(x):
       'Calculates the square of the number x.'
       return x*x
   #+END_SRC

   The docstring may be accessed like this:

   #+BEGIN_SRC python
   >>> square.__doc__
   'Calculates the square of the number x.'
   #+END_SRC

   *Note:*__doc__ is a function attribute.

   A special built-in function called help can be quite useful. If you use it in the
   interactive interpreter, you can get information about a function, including its
   docstring:

   #+BEGIN_SRC python
   >>> help(square)
   Help on function square in module __main__:

   square(x)
   Calculates the square of the number x.
   #+END_SRC

** patameters
   *Note:* Parameters are kept in what is called a *local scope*.

   Strings (and numbers and tuples) are immutable, which means that you can’t modify
   them (that is, you can only replace them with new values).

   When two variables refer to the same list, they . . . refer to the same list. It’s
   really as simple as that. If you want to avoid this, you must make a copy of the list.
   When you do slicing on a sequence, the returned slice is always a copy. Thus, if
   you make a slice of the entire list, you get a copy:

   #+BEGIN_SRC python
   >>> names = ['Mrs. Entity', 'Mrs. Thing']
   >>> n = names[:]
   #+END_SRC

   In some languages (such as C++, Pascal, and Ada), rebinding parameters and having
   these changes affect variables outside the function is an everyday thing. In Python,
   it’s not directly possible; you can modify only the parameter objects themselves.


   The parameters that are supplied with a name like this are called keyword parameters.
   On their own, the key strength of keyword parameters is that they can help clarify
   the role of each parameter.

   #+BEGIN_SRC python
   >>> hello(greeting='Hello', name='world')
   Hello, world!
   #+END_SRC

   What really makes keyword arguments rock, however, is that you can give the parameters
   in the function default values:

   #+BEGIN_SRC python
   def hello(greeting='Hello', name='world'):
       print '%s, %s!' % (greeting, name)
   #+END_SRC

   When a parameter has a default value like this, you don’t need to supply it when
   you call the function! You can supply none, some, or all, as the situation might
   dictate:

   #+BEGIN_SRC python
   >>> hello()
   Hello, world!
   >>> hello('Greetings')
   Greetings, world!
   >>> hello('Greetings', 'universe')
   Greetings, universe!
   #+END_SRC

   As you can see, this works well with positional parameters, except that you must
   supply the greeting if you want to supply the name. What if you want to supply
   only the name, leaving the default value for the greeting?

   #+BEGIN_SRC python
   >>> hello(name='Gumby')
   Hello, Gumby!
   #+END_SRC

*** collecting parameters
    Sometimes it can be useful to allow the user to supply any number of parameters.
    For example, you can store only one name at a time. It would be nice to be able
    to store more names, like this:

    #+BEGIN_SRC python
    >>> store(data, name1, name2, name3)
    #+END_SRC

    For this to be useful, you should be allowed to supply as many names as you want.
    Actually, that’s quite possible.

    #+BEGIN_SRC python
    def print_params(*params):
        print params

    >>> print_params('Testing')
    ('Testing',)
    >>> print_params(1, 2, 3)
    (1, 2, 3)
    #+END_SRC

    The star in front of the parameter puts all the values into the same tuple.
    Does it handle keyword arguments (the same as parameters), too?

    #+BEGIN_SRC python
    >>> print_params_2('Hmm...', something=42)
    Traceback (most recent call last):
    File "<pyshell#60>", line 1, in ?
    print_params_2('Hmm...', something=42)
    TypeError: print_params_2() got an unexpected keyword argument 'something'
    #+END_SRC

    So we probably need another “gathering” operator for keyword arguments. What
    do you think that might be? Perhaps **?

    #+BEGIN_SRC python
    def print_params_3(**params):
        print params

    >>> print_params_3(x=1, y=2, z=3)
    {'z': 3, 'x': 1, 'y': 2}
    #+END_SRC

    Yep, we get a dictionary rather than a tuple. Let’s put them all together:

    #+BEGIN_SRC python
    def print_params_4(x, y, z=3, *pospar, **keypar):
        print x, y, z
        print pospar
        print keypar
    #+END_SRC
    This works just as expected:

    #+BEGIN_SRC python
    >>> print_params_4(1, 2, 3, 5, 6, 7, foo=1, bar=2)
    1 2 3
    (5, 6, 7)
    {'foo': 1, 'bar': 2}
    >>> print_params_4(1, 2)
    1 2 3
    ()
    {}
    #+END_SRC

*** reversing the process
    Let's say you have with two numbers that you want to add:

    #+BEGIN_SRC python
    def add(x ,y): return x + y
    params = (1, 2)
    #+END_SRC

    Instead of gathering the parameters, we want to /distribute/ them. This is
    simply done by using the * operator at the "other end" -- that is, when
    calling the function rather than when defining it:

    #+BEGIN_SRC python
    >>> add(*params)
    3
    #+END_SRC

    We can use the same technique with dictionaries, using the ** operator.
    Using * (or **) both when you define and call the function will simply pass
    the tuple or dictionary right through, so you might as well not have
    bothered:

    #+BEGIN_SRC python
    >>> def with_stars(**kwds):
        print kwds['name'], 'is', kwds['age'], 'years old'

    >>> def without_stars(kwds):
        print kwds['name'], 'is', kwds['age'], 'years old'
    >>> args = {'name': 'Mr. Me', 'age': 42}
    >>> with_stars(**args)
    Mr. Me is 42 years old
    >>> without_stars(args)
    Mr. Me is 42 years old
    #+END_SRC

    *Tip:* It may be useful to use these splicing operators to “pass through”
    parameters, without worrying too much about how many there are, and so forth.
    Here is an example:

    #+BEGIN_SRC python
    def foo(x, y, z, m=0, n=0):
        print x, y, z, m, n
    def call_foo(*args,**kwds):
        print "Calling foo!"
        foo(*args,**kwds)
    #+END_SRC

    This can be particularly useful when calling the constructor of a superclass
